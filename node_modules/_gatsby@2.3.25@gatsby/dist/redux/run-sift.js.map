{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["sift","require","_","prepareRegex","resolveNodes","resolveRecursive","siftifyArgs","object","newObject","each","v","k","isPlainObject","Minimatch","mm","makeRe","extractFieldsToSift","filter","Object","keys","reduce","acc","key","value","parseFilter","siftArgs","fieldsToSift","push","isEqId","firstOnly","length","id","handleFirst","nodes","index","isEmpty","indexOf","$and","handleMany","sort","result","sortFields","fields","map","field","get","sortOrder","order","toLowerCase","orderBy","module","exports","args","getNode","getNodesByType","queryArgs","gqlType","name","node","internal","type","getFields","then","resolvedNodes"],"mappings":"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","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`../utils/prepare-regex`)\nconst { resolveNodes, resolveRecursive } = require(`./prepare-nodes`)\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nfunction siftifyArgs(object) {\n  const newObject = {}\n  _.each(object, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        k = `$elemMatch`\n      }\n      newObject[k] = siftifyArgs(v)\n    } else {\n      // Compile regex first.\n      if (k === `regex`) {\n        newObject[`$regex`] = prepareRegex(v)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        newObject[`$regex`] = mm.makeRe()\n      } else {\n        newObject[`$${k}`] = v\n      }\n    }\n  })\n  return newObject\n}\n\n// Build an object that excludes the innermost leafs,\n// this avoids including { eq: x } when resolving fields.\nconst extractFieldsToSift = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    let value = filter[key]\n    let k = Object.keys(value)[0]\n    let v = value[k]\n    if (_.isPlainObject(value) && _.isPlainObject(v)) {\n      acc[key] =\n        k === `elemMatch` ? extractFieldsToSift(v) : extractFieldsToSift(value)\n    } else {\n      acc[key] = true\n    }\n    return acc\n  }, {})\n\n/**\n * Parse filter and returns an object with two fields:\n * - siftArgs: the filter in a format that sift understands\n * - fieldsToSift: filter with operate leaves (e.g { eq: 3 })\n *   removed. Used later to resolve all filter fields\n */\nfunction parseFilter(filter) {\n  const siftArgs = []\n  let fieldsToSift = {}\n  if (filter) {\n    _.each(filter, (v, k) => {\n      siftArgs.push(\n        siftifyArgs({\n          [k]: v,\n        })\n      )\n    })\n    fieldsToSift = extractFieldsToSift(filter)\n  }\n  return { siftArgs, fieldsToSift }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(firstOnly, fieldsToSift, siftArgs) {\n  return (\n    firstOnly &&\n    Object.keys(fieldsToSift).length === 1 &&\n    Object.keys(fieldsToSift)[0] === `id` &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction handleFirst(siftArgs, nodes) {\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : sift.indexOf(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes, sort) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : sift(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (!result || !result.length) return null\n\n  // Sort results.\n  if (sort) {\n    // create functions that return the item to compare on\n    // uses _.get so nested fields can be retrieved\n    const sortFields = sort.fields.map(field => v => _.get(v, field))\n    const sortOrder = sort.order.map(order => order.toLowerCase())\n\n    result = _.orderBy(result, sortFields, sortOrder)\n  }\n  return result\n}\n\n/**\n * Filters a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter as an object\n * @param nodes The nodes array to run sift over (Optional\n *   will load itself if not present)\n * @param type gqlType. Created in build-node-types\n * @param firstOnly true if you want to return only the first result\n *   found. This will return a collection of size 1. Not a single\n *   element\n * @returns Collection of results. Collection will be limited to size\n *   if `firstOnly` is true\n */\nmodule.exports = (args: Object) => {\n  const { getNode, getNodesByType } = require(`../db/nodes`)\n\n  const { queryArgs, gqlType, firstOnly = false } = args\n\n  // If nodes weren't provided, then load them from the DB\n  const nodes = args.nodes || getNodesByType(gqlType.name)\n\n  const { siftArgs, fieldsToSift } = parseFilter(queryArgs.filter)\n  // FIXME: fieldsToSift must include `sort.fields` as well as the\n  // `field` arg on `group` and `distinct`\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(firstOnly, fieldsToSift, siftArgs)) {\n    const node = getNode(siftArgs[0].id[`$eq`])\n\n    if (!node || (node.internal && node.internal.type !== gqlType.name)) {\n      return []\n    }\n\n    return resolveRecursive(node, fieldsToSift, gqlType.getFields()).then(\n      node => (node ? [node] : [])\n    )\n  }\n\n  return resolveNodes(\n    nodes,\n    gqlType.name,\n    firstOnly,\n    fieldsToSift,\n    gqlType.getFields()\n  ).then(resolvedNodes => {\n    if (firstOnly) {\n      return handleFirst(siftArgs, resolvedNodes)\n    } else {\n      return handleMany(siftArgs, resolvedNodes, queryArgs.sort)\n    }\n  })\n}\n"],"file":"run-sift.js"}