{"version":3,"sources":["../../src/db/nodes-query.js"],"names":["_","require","getNamedType","lokiRunQuery","siftRunQuery","dropQueryOperators","filter","Object","keys","reduce","acc","key","value","k","v","isPlainObject","hasFieldResolvers","type","filterFields","fields","getFields","some","fieldName","filterValue","field","Boolean","resolve","chooseQueryEngine","args","backend","queryArgs","gqlType","nodes","run","queryFunction","module","exports"],"mappings":";;AAAA,MAAMA,CAAC,GAAGC,OAAO,CAAE,QAAF,CAAjB;;iBACyBA,OAAO,CAAE,SAAF,C;MAAxBC,Y,YAAAA,Y;;AAER,MAAMC,YAAY,GAAGF,OAAO,CAAE,oBAAF,CAA5B;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAE,mBAAF,CAA5B,C,CAEA;;;AACA,MAAMI,kBAAkB,GAAGC,MAAM,IAC/BC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBG,MAApB,CAA2B,CAACC,GAAD,EAAMC,GAAN,KAAc;AACvC,MAAIC,KAAK,GAAGN,MAAM,CAACK,GAAD,CAAlB;AACA,MAAIE,CAAC,GAAGN,MAAM,CAACC,IAAP,CAAYI,KAAZ,EAAmB,CAAnB,CAAR;AACA,MAAIE,CAAC,GAAGF,KAAK,CAACC,CAAD,CAAb;;AACA,MAAIb,CAAC,CAACe,aAAF,CAAgBH,KAAhB,KAA0BZ,CAAC,CAACe,aAAF,CAAgBD,CAAhB,CAA9B,EAAkD;AAChDJ,IAAAA,GAAG,CAACC,GAAD,CAAH,GACEE,CAAC,KAAM,WAAP,GAAoBR,kBAAkB,CAACS,CAAD,CAAtC,GAA4CT,kBAAkB,CAACO,KAAD,CADhE;AAED,GAHD,MAGO;AACLF,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAW,IAAX;AACD;;AACD,SAAOD,GAAP;AACD,CAXD,EAWG,EAXH,CADF;;AAcA,MAAMM,iBAAiB,GAAG,CAACC,IAAD,EAAOC,YAAP,KAAwB;AAChD,QAAMC,MAAM,GAAGF,IAAI,CAACG,SAAL,EAAf;AACA,SAAOb,MAAM,CAACC,IAAP,CAAYU,YAAZ,EAA0BG,IAA1B,CAA+BC,SAAS,IAAI;AACjD,UAAMC,WAAW,GAAGL,YAAY,CAACI,SAAD,CAAhC;AACA,UAAME,KAAK,GAAGL,MAAM,CAACG,SAAD,CAApB;AACA,WACEG,OAAO,CAACD,KAAK,CAACE,OAAP,CAAP,IACCH,WAAW,KAAK,IAAhB,IACCP,iBAAiB,CAACd,YAAY,CAACsB,KAAK,CAACP,IAAP,CAAb,EAA2BM,WAA3B,CAHrB;AAKD,GARM,CAAP;AASD,CAXD;;AAaA,SAASI,iBAAT,CAA2BC,IAA3B,EAAiC;AAAA,oBACX3B,OAAO,CAAE,SAAF,CADI;AAAA,QACvB4B,OADuB,aACvBA,OADuB;;AAAA,QAGvBC,SAHuB,GAGAF,IAHA,CAGvBE,SAHuB;AAAA,QAGZC,OAHY,GAGAH,IAHA,CAGZG,OAHY,EAI/B;AACA;;AAL+B,QAMvBzB,MANuB,GAMZwB,SANY,CAMvBxB,MANuB;AAO/B,QAAMa,MAAM,GAAGb,MAAM,GAAGD,kBAAkB,CAACC,MAAD,CAArB,GAAgC,EAArD,CAP+B,CAS/B;;AACA,MACEuB,OAAO,KAAM,MAAb,IACA,CAACD,IAAI,CAACI,KADN,IAEA,CAAChB,iBAAiB,CAACe,OAAD,EAAUZ,MAAV,CAHpB,EAIE;AACA,WAAOhB,YAAP;AACD,GAND,MAMO;AACL,WAAOC,YAAP;AACD;AACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,SAAS6B,GAAT,CAAaL,IAAb,EAAmB;AACjB,QAAMM,aAAa,GAAGP,iBAAiB,CAACC,IAAD,CAAvC;AAEA,SAAOM,aAAa,CAACN,IAAD,CAApB;AACD;;AAEDO,MAAM,CAACC,OAAP,CAAeH,GAAf,GAAqBA,GAArB","sourcesContent":["const _ = require(`lodash`)\nconst { getNamedType } = require(`graphql`)\n\nconst lokiRunQuery = require(`./loki/nodes-query`)\nconst siftRunQuery = require(`../redux/run-sift`)\n\n// FIXME: This is duplicate code (`extractFieldsToSift`)\nconst dropQueryOperators = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    let value = filter[key]\n    let k = Object.keys(value)[0]\n    let v = value[k]\n    if (_.isPlainObject(value) && _.isPlainObject(v)) {\n      acc[key] =\n        k === `elemMatch` ? dropQueryOperators(v) : dropQueryOperators(value)\n    } else {\n      acc[key] = true\n    }\n    return acc\n  }, {})\n\nconst hasFieldResolvers = (type, filterFields) => {\n  const fields = type.getFields()\n  return Object.keys(filterFields).some(fieldName => {\n    const filterValue = filterFields[fieldName]\n    const field = fields[fieldName]\n    return (\n      Boolean(field.resolve) ||\n      (filterValue !== true &&\n        hasFieldResolvers(getNamedType(field.type), filterValue))\n    )\n  })\n}\n\nfunction chooseQueryEngine(args) {\n  const { backend } = require(`./nodes`)\n\n  const { queryArgs, gqlType } = args\n  // TODO: Resolve nodes on sort fields\n  // TODO: Need to get group and distinct `field` arg from projection\n  const { filter } = queryArgs\n  const fields = filter ? dropQueryOperators(filter) : {}\n\n  // NOTE: `hasFieldResolvers` is also true for Date fields\n  if (\n    backend === `loki` &&\n    !args.nodes &&\n    !hasFieldResolvers(gqlType, fields)\n  ) {\n    return lokiRunQuery\n  } else {\n    return siftRunQuery\n  }\n}\n\n/**\n * Runs the query over all nodes of type. It must first select the\n * appropriate query engine. Sift, or Loki. Sift is used by default,\n * or if the query includes fields with custom resolver functions,\n * those that need to be resolved before being queried.\n * These could be either plugin fields, i.e those declared by plugins during\n * the `setFieldsOnGraphQLNodeType` API, or they could be linked fields.\n * See `../redux/run-sift.js` for more.\n *\n * If the query does *not* include fields with custom resolver functions,\n * and environment variable `GATSBY_DB_NODES` = `loki` then we can perform\n * a much faster pure data query using loki. See `loki/nodes-query.js` for\n * more.\n *\n * @param {Object} args. Object with:\n *\n * {Object} gqlType: built during `./build-node-types.js`\n *\n * {Object} queryArgs: The raw graphql query as a js object. E.g `{\n * filter: { fields { slug: { eq: \"/somepath\" } } } }`\n *\n * {Object} context: The context from the QueryJob\n *\n * {boolean} firstOnly: Whether to return the first found match, or\n * all matching result.\n *\n * @returns {promise} A promise that will eventually be resolved with\n * a collection of matching objects (even if `firstOnly` is true, in\n * which case it will be a collection of length 1 or zero)\n */\nfunction run(args) {\n  const queryFunction = chooseQueryEngine(args)\n\n  return queryFunction(args)\n}\n\nmodule.exports.run = run\n"],"file":"nodes-query.js"}