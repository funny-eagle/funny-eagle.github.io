{"version":3,"sources":["../../src/query/index.js"],"names":["_","require","Queue","convertHrtime","store","emitter","queryQueue","boundActionCreators","seenIdsWithoutDataDependencies","queuedDirtyActions","extractedQueryIds","Set","on","action","filter","p","payload","path","push","popExtractedQueries","queries","clear","findIdsWithoutDataDependencies","state","allTrackedIds","uniq","flatten","concat","values","componentDataDependencies","nodes","connections","notTrackedIds","difference","Array","from","pages","staticQueryComponents","map","c","jsonName","popNodeQueries","actions","a","id","uniqDirties","reduce","dirtyIds","node","internal","type","compact","popNodeAndDepQueries","nodeQueries","noDepQueries","calcDirtyQueryIds","union","calcInitialDirtyQueryIds","nodeAndNoDepQueries","extractedQueriesThatNeedRunning","intersection","groupQueryIds","queryIds","grouped","groupBy","slice","staticQueryIds","static","pageQueryIds","page","reportStats","queue","activity","startQueries","process","hrtime","stats","getStats","setStatus","total","peak","seconds","toFixed","processQueries","queryJobs","createBuildQueue","processBatch","createStaticQueryJob","queryId","component","get","hash","query","componentPath","context","processStaticQueries","getState","createPageQueryJob","components","isPage","processPageQueries","listenerQueue","runQueuedQueries","startListening","callback","then","catch","enqueueExtractedQueryId","pathname","add","getPagesForComponent","enqueueExtractedPageComponent","deleteComponentsDependencies","forEach","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst _ = require(`lodash`)\nconst Queue = require(`better-queue`)\nconst convertHrtime = require(`convert-hrtime`)\nconst { store, emitter } = require(`../redux`)\nconst queryQueue = require(`./queue`)\nconst { boundActionCreators } = require(`../redux/actions`)\n\nlet seenIdsWithoutDataDependencies = []\nlet queuedDirtyActions = []\nconst extractedQueryIds = new Set()\n\n// Remove pages from seenIdsWithoutDataDependencies when they're deleted\n// so their query will be run again if they're created again.\nemitter.on(`DELETE_PAGE`, action => {\n  seenIdsWithoutDataDependencies = seenIdsWithoutDataDependencies.filter(\n    p => p !== action.payload.path\n  )\n})\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nemitter.on(`DELETE_NODE`, action => {\n  queuedDirtyActions.push({ payload: action.payload })\n})\n\n/////////////////////////////////////////////////////////////////////\n// Calculate dirty static/page queries\n\nconst popExtractedQueries = () => {\n  const queries = [...extractedQueryIds]\n  extractedQueryIds.clear()\n  return queries\n}\n\nconst findIdsWithoutDataDependencies = state => {\n  const allTrackedIds = _.uniq(\n    _.flatten(\n      _.concat(\n        _.values(state.componentDataDependencies.nodes),\n        _.values(state.componentDataDependencies.connections)\n      )\n    )\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  const notTrackedIds = _.difference(\n    [\n      ...Array.from(state.pages.values(), p => p.path),\n      ...[...state.staticQueryComponents.values()].map(c => c.jsonName),\n    ],\n    [...allTrackedIds, ...seenIdsWithoutDataDependencies]\n  )\n\n  // Add new IDs to our seen array so we don't keep trying to run queries for them.\n  // Pages without queries can't be tracked.\n  seenIdsWithoutDataDependencies = _.uniq([\n    ...notTrackedIds,\n    ...seenIdsWithoutDataDependencies,\n  ])\n\n  return notTrackedIds\n}\n\nconst popNodeQueries = state => {\n  const actions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  const uniqDirties = _.uniq(\n    actions.reduce((dirtyIds, action) => {\n      const node = action.payload\n\n      if (!node || !node.id || !node.internal.type) return dirtyIds\n\n      // Find components that depend on this node so are now dirty.\n      dirtyIds = dirtyIds.concat(state.componentDataDependencies.nodes[node.id])\n\n      // Find connections that depend on this node so are now invalid.\n      dirtyIds = dirtyIds.concat(\n        state.componentDataDependencies.connections[node.internal.type]\n      )\n\n      return _.compact(dirtyIds)\n    }, [])\n  )\n  queuedDirtyActions = []\n  return uniqDirties\n}\n\nconst popNodeAndDepQueries = state => {\n  const nodeQueries = popNodeQueries(state)\n\n  const noDepQueries = findIdsWithoutDataDependencies(state)\n\n  return _.uniq([...nodeQueries, ...noDepQueries])\n}\n\n/**\n * Calculates the set of dirty query IDs (page.paths, or\n * staticQuery.hash's). These are queries that:\n *\n * - depend on nodes or node collections (via\n *   `actions.createPageDependency`) that have changed.\n * - do NOT have node dependencies. Since all queries should return\n *   data, then this implies that node dependencies have not been\n *   tracked, and therefore these queries haven't been run before\n * - have been recently extracted (see `./query-watcher.js`)\n *\n * Note, this function pops queries off internal queues, so it's up\n * to the caller to reference the results\n */\n\nconst calcDirtyQueryIds = state =>\n  _.union(popNodeAndDepQueries(state), popExtractedQueries())\n\n/**\n * Same as `calcDirtyQueryIds`, except that we only include extracted\n * queries that depend on nodes or haven't been run yet. We do this\n * because the page component reducer/machine always enqueues\n * extractedQueryIds but during bootstrap we may not want to run those\n * page queries if their data hasn't changed since the last time we\n * ran Gatsby.\n */\nconst calcInitialDirtyQueryIds = state => {\n  const nodeAndNoDepQueries = popNodeAndDepQueries(state)\n\n  const extractedQueriesThatNeedRunning = _.intersection(\n    popExtractedQueries(),\n    nodeAndNoDepQueries\n  )\n  return _.union(extractedQueriesThatNeedRunning, nodeAndNoDepQueries)\n}\n\n/**\n * groups queryIds by whether they are static or page queries.\n */\nconst groupQueryIds = queryIds => {\n  const grouped = _.groupBy(queryIds, p =>\n    p.slice(0, 4) === `sq--` ? `static` : `page`\n  )\n  return {\n    staticQueryIds: grouped.static || [],\n    pageQueryIds: grouped.page || [],\n  }\n}\n\nconst reportStats = (queue, activity) => {\n  const startQueries = process.hrtime()\n  queue.on(`task_finish`, () => {\n    const stats = queue.getStats()\n    activity.setStatus(\n      `${stats.total}/${stats.peak} ${(\n        stats.total / convertHrtime(process.hrtime(startQueries)).seconds\n      ).toFixed(2)} queries/second`\n    )\n  })\n}\n\nconst processQueries = async (queryJobs, activity) => {\n  const queue = queryQueue.createBuildQueue()\n  reportStats(queue, activity)\n  await queryQueue.processBatch(queue, queryJobs)\n}\n\nconst createStaticQueryJob = (state, queryId) => {\n  const component = state.staticQueryComponents.get(queryId)\n  const { hash, jsonName, query, componentPath } = component\n  return {\n    id: hash,\n    hash,\n    jsonName,\n    query,\n    componentPath,\n    context: { path: jsonName },\n  }\n}\n\nconst processStaticQueries = async (queryIds, { state, activity }) => {\n  state = state || store.getState()\n  await processQueries(\n    queryIds.map(id => createStaticQueryJob(state, id)),\n    activity\n  )\n}\n\nconst createPageQueryJob = (state, page) => {\n  const component = state.components.get(page.componentPath)\n  const { path, jsonName, componentPath, context } = page\n  const { query } = component\n  return {\n    id: path,\n    jsonName,\n    query,\n    isPage: true,\n    componentPath,\n    context: {\n      ...page,\n      ...context,\n    },\n  }\n}\n\nconst processPageQueries = async (queryIds, { state, activity }) => {\n  state = state || store.getState()\n  // Make sure we filter out pages that don't exist. An example is\n  // /dev-404-page/, whose SitePage node is created via\n  // `internal-data-bridge`, but the actual page object is only\n  // created during `gatsby develop`.\n  const pages = _.filter(queryIds.map(id => state.pages.get(id)))\n  await processQueries(\n    pages.map(page => createPageQueryJob(state, page)),\n    activity\n  )\n}\n\n/////////////////////////////////////////////////////////////////////\n// Listener for gatsby develop\n\n// Initialized via `startListening`\nlet listenerQueue\n\n/**\n * Run any dirty queries. See `calcQueries` for what constitutes a\n * dirty query\n */\nconst runQueuedQueries = () => {\n  if (listenerQueue) {\n    const state = store.getState()\n    const { staticQueryIds, pageQueryIds } = groupQueryIds(\n      calcDirtyQueryIds(state)\n    )\n    const pages = _.filter(pageQueryIds.map(id => state.pages.get(id)))\n    const queryJobs = [\n      ...staticQueryIds.map(id => createStaticQueryJob(state, id)),\n      ...pages.map(page => createPageQueryJob(state, page)),\n    ]\n    listenerQueue.push(queryJobs)\n  }\n}\n\n/**\n * Starts a background process that processes any dirty queries\n * whenever one of the following occurs:\n *\n * 1. A node has changed (but only after the api call has finished\n * running)\n * 2. A component query (e.g by editing a React Component) has\n * changed\n *\n * For what constitutes a dirty query, see `calcQueries`\n */\nconst startListening = queue => {\n  // We use a queue to process batches of queries so that they are\n  // processed consecutively\n  listenerQueue = new Queue((queryJobs, callback) =>\n    queryQueue\n      .processBatch(queue, queryJobs)\n      .then(() => callback(null))\n      .catch(callback)\n  )\n\n  emitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedQueries)\n}\n\nconst enqueueExtractedQueryId = pathname => {\n  extractedQueryIds.add(pathname)\n}\n\nconst getPagesForComponent = componentPath => {\n  const state = store.getState()\n  return [...state.pages.values()].filter(\n    p => p.componentPath === componentPath\n  )\n}\n\nconst enqueueExtractedPageComponent = componentPath => {\n  const pages = getPagesForComponent(componentPath)\n  // Remove page data dependencies before re-running queries because\n  // the changing of the query could have changed the data dependencies.\n  // Re-running the queries will add back data dependencies.\n  boundActionCreators.deleteComponentsDependencies(\n    pages.map(p => p.path || p.id)\n  )\n  pages.forEach(page => enqueueExtractedQueryId(page.path))\n  runQueuedQueries()\n}\n\nmodule.exports = {\n  calcInitialDirtyQueryIds,\n  groupQueryIds,\n  processStaticQueries,\n  processPageQueries,\n  startListening,\n  runQueuedQueries,\n  enqueueExtractedQueryId,\n  enqueueExtractedPageComponent,\n}\n"],"file":"index.js"}