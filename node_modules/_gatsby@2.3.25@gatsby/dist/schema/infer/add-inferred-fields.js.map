{"version":3,"sources":["../../../src/schema/infer/add-inferred-fields.js"],"names":["_","require","defaultFieldResolver","getNamedType","GraphQLObjectType","GraphQLList","ObjectTypeComposer","invariant","report","isFile","link","fileByPath","isDate","dateResolver","is32BitInteger","addInferredFields","schemaComposer","typeComposer","exampleValue","nodeStore","inferConfig","typeMapping","parentSpan","addInferredFieldsImpl","exampleObject","prefix","getTypeName","addNewFields","infer","addDefaultResolvers","module","exports","fields","Object","keys","forEach","unsanitizedKey","push","getFieldConfig","fieldsByKey","groupBy","field","key","possibleFields","fieldConfig","length","resolveMultipleFields","possibleFieldsNames","map","join","warn","arrays","namedInferredType","type","Array","isArray","hasField","fieldType","getFieldType","lists","namedFieldType","ofType","namedInferredTypeName","name","fieldTypeComposer","getFieldTC","inferredFields","getFields","addFields","getField","isEmpty","args","resolve","setField","add","createFieldName","selector","value","hasMapping","getFieldConfigFromMapping","includes","getFieldConfigFromFieldNameConvention","split","getSimpleFieldConfig","resolver","source","context","info","fieldName","nodeField","find","canonicalField","sortBy","mapping","path","by","foreignKey","replace","getNodeBy","getNodes","node","get","getNode","linkedNodes","linkedTypes","uniq","filter","Boolean","internal","typeName","sort","getOrCreateUTC","utc","types","getOrCreateOTC","setTypes","setResolveType","has","Date","String","originalFieldTypeComposer","clone","createTemp","createTypeName","Error","suffix","slice","upperFirst","NON_ALPHA_NUMERIC_EXPR","RegExp","replaced","match","char","index"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst {\n  defaultFieldResolver,\n  getNamedType,\n  GraphQLObjectType,\n  GraphQLList,\n} = require(`graphql`)\nconst { ObjectTypeComposer } = require(`graphql-compose`)\nconst invariant = require(`invariant`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nconst { isFile } = require(`./is-file`)\nconst { link, fileByPath } = require(`../resolvers`)\nconst { isDate, dateResolver } = require(`../types/date`)\nconst is32BitInteger = require(`./is-32-bit-integer`)\n\nconst addInferredFields = ({\n  schemaComposer,\n  typeComposer,\n  exampleValue,\n  nodeStore,\n  inferConfig,\n  typeMapping,\n  parentSpan,\n}) => {\n  addInferredFieldsImpl({\n    schemaComposer,\n    typeComposer,\n    nodeStore,\n    exampleObject: exampleValue,\n    prefix: typeComposer.getTypeName(),\n    typeMapping,\n    addNewFields: inferConfig ? inferConfig.infer : true,\n    addDefaultResolvers: inferConfig ? inferConfig.addDefaultResolvers : true,\n  })\n}\n\nmodule.exports = {\n  addInferredFields,\n}\n\nconst addInferredFieldsImpl = ({\n  schemaComposer,\n  typeComposer,\n  nodeStore,\n  exampleObject,\n  typeMapping,\n  prefix,\n  addNewFields,\n  addDefaultResolvers,\n}) => {\n  const fields = []\n  Object.keys(exampleObject).forEach(unsanitizedKey => {\n    const exampleValue = exampleObject[unsanitizedKey]\n    fields.push(\n      getFieldConfig({\n        schemaComposer,\n        typeComposer,\n        nodeStore,\n        prefix,\n        exampleValue,\n        unsanitizedKey,\n        typeMapping,\n        addNewFields,\n        addDefaultResolvers,\n      })\n    )\n  })\n\n  const fieldsByKey = _.groupBy(fields, field => field.key)\n\n  Object.keys(fieldsByKey).forEach(key => {\n    const possibleFields = fieldsByKey[key]\n    let fieldConfig\n    if (possibleFields.length > 1) {\n      const field = resolveMultipleFields(possibleFields)\n      const possibleFieldsNames = possibleFields\n        .map(field => `\\`${field.unsanitizedKey}\\``)\n        .join(`, `)\n      report.warn(\n        `Multiple node fields resolve to the same GraphQL field \\`${prefix}.${\n          field.key\n        }\\` - [${possibleFieldsNames}]. Gatsby will use \\`${\n          field.unsanitizedKey\n        }\\`.`\n      )\n      fieldConfig = field.fieldConfig\n    } else {\n      fieldConfig = possibleFields[0].fieldConfig\n    }\n\n    let arrays = 0\n    let namedInferredType = fieldConfig.type\n    while (Array.isArray(namedInferredType)) {\n      namedInferredType = namedInferredType[0]\n      arrays++\n    }\n\n    if (typeComposer.hasField(key)) {\n      const fieldType = typeComposer.getFieldType(key)\n\n      let lists = 0\n      let namedFieldType = fieldType\n      while (namedFieldType.ofType) {\n        if (namedFieldType instanceof GraphQLList) {\n          lists++\n        }\n        namedFieldType = namedFieldType.ofType\n      }\n\n      const namedInferredTypeName =\n        typeof namedInferredType === `string`\n          ? namedInferredType\n          : namedInferredType.getTypeName()\n\n      if (arrays === lists && namedFieldType.name === namedInferredTypeName) {\n        if (\n          namedFieldType instanceof GraphQLObjectType &&\n          namedInferredType instanceof ObjectTypeComposer\n        ) {\n          const fieldTypeComposer = typeComposer.getFieldTC(key)\n          const inferredFields = namedInferredType.getFields()\n          fieldTypeComposer.addFields(inferredFields)\n        }\n        if (addDefaultResolvers) {\n          let field = typeComposer.getField(key)\n          if (!field.type) {\n            field = {\n              type: field,\n            }\n          }\n          if (_.isEmpty(field.args) && fieldConfig.args) {\n            field.args = fieldConfig.args\n          }\n          if (!field.resolve && fieldConfig.resolve) {\n            field.resolve = fieldConfig.resolve\n          }\n          typeComposer.setField(key, field)\n        }\n      }\n    } else if (addNewFields) {\n      if (namedInferredType instanceof ObjectTypeComposer) {\n        schemaComposer.add(namedInferredType)\n      }\n      typeComposer.setField(key, fieldConfig)\n    }\n  })\n\n  return typeComposer\n}\n\nconst getFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  nodeStore,\n  prefix,\n  exampleValue,\n  unsanitizedKey,\n  typeMapping,\n  addNewFields,\n  addDefaultResolvers,\n}) => {\n  let key = createFieldName(unsanitizedKey)\n  const selector = `${prefix}.${key}`\n\n  let arrays = 0\n  let value = exampleValue\n  while (Array.isArray(value)) {\n    value = value[0]\n    arrays++\n  }\n\n  let fieldConfig\n  if (hasMapping(typeMapping, selector)) {\n    // TODO: Use `prefix` instead of `selector` in hasMapping and getFromMapping?\n    // i.e. does the config contain sanitized field names?\n    fieldConfig = getFieldConfigFromMapping({ typeMapping, selector })\n  } else if (key.includes(`___NODE`)) {\n    fieldConfig = getFieldConfigFromFieldNameConvention({\n      schemaComposer,\n      nodeStore,\n      value: exampleValue,\n      key: unsanitizedKey,\n    })\n    key = key.split(`___NODE`)[0]\n  } else {\n    fieldConfig = getSimpleFieldConfig({\n      schemaComposer,\n      typeComposer,\n      nodeStore,\n      key,\n      value,\n      selector,\n      typeMapping,\n      addNewFields,\n      addDefaultResolvers,\n    })\n  }\n\n  // Proxy resolver to unsanitized fieldName in case it contained invalid characters\n  if (key !== unsanitizedKey) {\n    const resolver = fieldConfig.resolve || defaultFieldResolver\n    fieldConfig = {\n      ...fieldConfig,\n      resolve: (source, args, context, info) =>\n        resolver(source, args, context, {\n          ...info,\n          fieldName: unsanitizedKey,\n        }),\n    }\n  }\n\n  while (arrays > 0) {\n    fieldConfig = { ...fieldConfig, type: [fieldConfig.type] }\n    arrays--\n  }\n\n  return {\n    key,\n    unsanitizedKey,\n    fieldConfig,\n  }\n}\n\nconst resolveMultipleFields = possibleFields => {\n  const nodeField = possibleFields.find(field =>\n    field.unsanitizedKey.includes(`___NODE`)\n  )\n  if (nodeField) {\n    return nodeField\n  }\n\n  const canonicalField = possibleFields.find(\n    field => field.unsanitizedKey === field.key\n  )\n  if (canonicalField) {\n    return canonicalField\n  }\n\n  return _.sortBy(possibleFields, field => field.unsanitizedKey)[0]\n}\n\n// XXX(freiksenet): removing this as it's a breaking change\n// Deeper nested levels should be inferred as JSON.\n// const MAX_DEPTH = 5\n\nconst hasMapping = (mapping, selector) =>\n  mapping && Object.keys(mapping).includes(selector)\n\nconst getFieldConfigFromMapping = ({ typeMapping, selector }) => {\n  const [type, ...path] = typeMapping[selector].split(`.`)\n  return { type, resolve: link({ by: path.join(`.`) || `id` }) }\n}\n\n// probably should be in example value\nconst getFieldConfigFromFieldNameConvention = ({\n  schemaComposer,\n  nodeStore,\n  value,\n  key,\n}) => {\n  const path = key.split(`___NODE___`)[1]\n  // Allow linking by nested fields, e.g. `author___NODE___contact___email`\n  const foreignKey = path && path.replace(/___/g, `.`)\n\n  const getNodeBy = value =>\n    foreignKey\n      ? nodeStore.getNodes().find(node => _.get(node, foreignKey) === value)\n      : nodeStore.getNode(value)\n\n  const linkedNodes = Array.isArray(value)\n    ? value.map(getNodeBy)\n    : [getNodeBy(value)]\n\n  const linkedTypes = _.uniq(\n    linkedNodes.filter(Boolean).map(node => node.internal.type)\n  )\n\n  invariant(\n    linkedTypes.length,\n    `Encountered an error trying to infer a GraphQL type for: \\`${key}\\`. ` +\n      `There is no corresponding node with the \\`id\\` field matching: \"${value}\".`\n  )\n\n  let type\n  // If the field value is an array that links to more than one type,\n  // create a GraphQLUnionType. Note that we don't support the case where\n  // scalar fields link to different types. Similarly, an array of objects\n  // with foreign-key fields will produce union types if those foreign-key\n  // fields are arrays, but not if they are scalars. See the tests for an example.\n  // FIXME: The naming of union types is a breaking change. In current master,\n  // the type name includes the key, which is (i) potentially not unique, and\n  // (ii) hinders reusing types.\n  if (linkedTypes.length > 1) {\n    const typeName = linkedTypes.sort().join(``) + `Union`\n    type = schemaComposer.getOrCreateUTC(typeName, utc => {\n      const types = linkedTypes.map(typeName =>\n        schemaComposer.getOrCreateOTC(typeName)\n      )\n      utc.setTypes(types)\n      utc.setResolveType(node => node.internal.type)\n    })\n  } else {\n    type = linkedTypes[0]\n  }\n\n  return { type, resolve: link({ by: foreignKey || `id` }) }\n}\n\nconst getSimpleFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  nodeStore,\n  key,\n  value,\n  selector,\n  typeMapping,\n  addNewFields,\n  addDefaultResolvers,\n}) => {\n  switch (typeof value) {\n    case `boolean`:\n      return { type: `Boolean` }\n    case `number`:\n      return { type: is32BitInteger(value) ? `Int` : `Float` }\n    case `string`:\n      if (isDate(value)) {\n        return dateResolver\n      }\n      // FIXME: The weird thing is that we are trying to infer a File,\n      // but cannot assume that a source plugin for File nodes is actually present.\n      if (schemaComposer.has(`File`) && isFile(nodeStore, selector, value)) {\n        // NOTE: For arrays of files, where not every path references\n        // a File node in the db, it is semi-random if the field is\n        // inferred as File or String, since the exampleValue only has\n        // the first entry (which could point to an existing file or not).\n        return { type: `File`, resolve: fileByPath }\n      }\n      return { type: `String` }\n    case `object`:\n      if (value instanceof Date) {\n        return dateResolver\n      }\n      if (value instanceof String) {\n        return { type: `String` }\n      }\n      if (value /* && depth < MAX_DEPTH*/) {\n        // We only create a temporary TypeComposer on nested fields\n        // (either a clone of an existing field type, or a temporary new one),\n        // because we don't yet know if this type should end up in the schema.\n        // It might be for a possibleField that will be disregarded later,\n        // so we cannot mutate the original.\n        let fieldTypeComposer\n        if (\n          typeComposer.hasField(key) &&\n          getNamedType(typeComposer.getFieldType(key)) instanceof\n            GraphQLObjectType\n        ) {\n          const originalFieldTypeComposer = typeComposer.getFieldTC(key)\n          fieldTypeComposer = originalFieldTypeComposer.clone(\n            originalFieldTypeComposer.getTypeName()\n          )\n        } else {\n          fieldTypeComposer = ObjectTypeComposer.createTemp(\n            createTypeName(selector),\n            schemaComposer\n          )\n        }\n\n        return {\n          type: addInferredFieldsImpl({\n            schemaComposer,\n            typeComposer: fieldTypeComposer,\n            nodeStore,\n            exampleObject: value,\n            typeMapping,\n            prefix: selector,\n            addNewFields,\n            addDefaultResolvers,\n          }),\n        }\n      }\n  }\n  throw new Error(`Can't determine type for \"${value}\" in \\`${selector}\\`.`)\n}\n\nconst createTypeName = selector => {\n  const keys = selector.split(`.`)\n  const suffix = keys\n    .slice(1)\n    .map(_.upperFirst)\n    .join(``)\n  return `${keys[0]}${suffix}`\n}\n\nconst NON_ALPHA_NUMERIC_EXPR = new RegExp(`[^a-zA-Z0-9_]`, `g`)\n\n/**\n * GraphQL field names must be a string and cannot contain anything other than\n * alphanumeric characters and `_`. They also can't start with `__` which is\n * reserved for internal fields (`___foo` doesn't work either).\n */\nconst createFieldName = key => {\n  // Check if the key is really a string otherwise GraphQL will throw.\n  invariant(\n    typeof key === `string`,\n    `GraphQL field name (key) is not a string: \\`${key}\\`.`\n  )\n\n  const replaced = key.replace(NON_ALPHA_NUMERIC_EXPR, `_`)\n\n  // key is invalid; normalize with leading underscore and rest with x\n  if (replaced.match(/^__/)) {\n    return replaced.replace(/_/g, (char, index) => (index === 0 ? `_` : `x`))\n  }\n\n  // key is invalid (starts with numeric); normalize with leading underscore\n  if (replaced.match(/^[0-9]/)) {\n    return `_` + replaced\n  }\n\n  return replaced\n}\n"],"file":"add-inferred-fields.js"}