"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var index_1 = require("../src/index");
var machine = index_1.Machine({
    type: 'parallel',
    states: {
        A: {
            initial: 'A1',
            states: {
                A1: {},
                A2: {}
            }
        },
        B: {
            initial: 'B1',
            states: {
                B1: {},
                B2: {}
            }
        }
    }
});
describe('invalid or resolved states', function () {
    it('should resolve a String state', function () {
        chai_1.assert.deepEqual(machine.transition('A', 'E').value, { A: 'A1', B: 'B1' });
    });
    it('should resolve transitions from empty states', function () {
        chai_1.assert.deepEqual(machine.transition({ A: {}, B: {} }, 'E').value, {
            A: 'A1',
            B: 'B1'
        });
    });
    it('should allow transitioning from valid states', function () {
        machine.transition({ A: 'A1', B: 'B1' }, 'E');
    });
    it('should reject transitioning from bad state configs', function () {
        chai_1.assert.throws(function () { return machine.transition({ A: 'A3', B: 'B3' }, 'E'); });
    });
    it('should resolve transitioning from partially valid states', function () {
        chai_1.assert.deepEqual(machine.transition({ A: 'A1', B: {} }, 'E').value, {
            A: 'A1',
            B: 'B1'
        });
    });
    it("should resolve transitioning from regions that don't exist (remove region)", function () {
        chai_1.assert.deepEqual(machine.transition({ A: 'A1', B: 'B1', Z: 'Z1' }, 'E').value, {
            A: 'A1',
            B: 'B1'
        });
    });
});
