"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var index_1 = require("../src/index");
var State_1 = require("../src/State");
var interpreter_1 = require("../src/interpreter");
var pedestrianStates = {
    initial: 'walk',
    states: {
        walk: {
            on: {
                PED_COUNTDOWN: 'wait'
            }
        },
        wait: {
            on: {
                PED_COUNTDOWN: 'stop'
            }
        },
        stop: {}
    }
};
var lightMachine = index_1.Machine({
    key: 'light',
    initial: 'green',
    states: {
        green: {
            on: {
                TIMER: 'yellow',
                POWER_OUTAGE: 'red',
                FORBIDDEN_EVENT: undefined
            }
        },
        yellow: {
            on: {
                TIMER: 'red',
                POWER_OUTAGE: 'red'
            }
        },
        red: __assign({ on: {
                TIMER: 'green',
                POWER_OUTAGE: 'red'
            } }, pedestrianStates)
    }
});
var configMachine = index_1.Machine({
    id: 'config',
    initial: 'foo',
    context: {
        foo: 'bar'
    },
    states: {
        foo: {
            onEntry: 'entryAction',
            on: {
                EVENT: {
                    target: 'bar',
                    cond: 'someCondition'
                }
            }
        },
        bar: {}
    }
}, {
    actions: {
        entryAction: function () {
            throw new Error('original entry');
        }
    },
    guards: {
        someCondition: function () { return false; }
    }
});
describe('machine', function () {
    describe('machine.states', function () {
        it('should properly register machine states', function () {
            chai_1.assert.deepEqual(Object.keys(lightMachine.states), [
                'green',
                'yellow',
                'red'
            ]);
        });
    });
    describe('machine.events', function () {
        it('should return the set of events accepted by machine', function () {
            chai_1.assert.sameMembers(lightMachine.events, [
                'TIMER',
                'POWER_OUTAGE',
                'PED_COUNTDOWN'
            ]);
        });
    });
    describe('machine.initialState', function () {
        it('should return a State instance', function () {
            chai_1.assert.instanceOf(lightMachine.initialState, State_1.State);
        });
        it('should return the initial state', function () {
            chai_1.assert.equal(lightMachine.initialState.value, 'green');
        });
    });
    describe('machine.history', function () {
        it('should not retain previous history', function () {
            var next = lightMachine.transition(lightMachine.initialState, 'TIMER');
            var following = lightMachine.transition(next, 'TIMER');
            chai_1.assert.isUndefined(following.history.history);
        });
    });
    describe('machine.withConfig', function () {
        it('should override guards and actions', function () {
            var differentMachine = configMachine.withConfig({
                actions: {
                    entryAction: function () {
                        throw new Error('new entry');
                    }
                },
                guards: { someCondition: function () { return true; } }
            });
            chai_1.assert.deepEqual(differentMachine.context, { foo: 'bar' }, 'context should be untouched');
            var service = interpreter_1.interpret(differentMachine);
            chai_1.assert.throws(function () { return service.start(); }, /new entry/, 'different action should be used');
            chai_1.assert.deepEqual(differentMachine.transition('foo', 'EVENT').value, 'bar');
        });
        it('should not override context if not defined', function () {
            var differentMachine = configMachine.withConfig({});
            chai_1.assert.deepEqual(differentMachine.initialState.context, configMachine.context);
        });
        it('should override context (second argument)', function () {
            var differentMachine = configMachine.withConfig({}, { foo: 'different' });
            chai_1.assert.deepEqual(differentMachine.initialState.context, {
                foo: 'different'
            });
        });
    });
});
describe('StateNode', function () {
    it('should list transitions', function () {
        var greenNode = lightMachine.states.green;
        var transitions = greenNode.transitions;
        chai_1.assert.deepEqual(transitions.map(function (t) { return t.event; }), [
            'TIMER',
            'POWER_OUTAGE',
            'FORBIDDEN_EVENT'
        ]);
    });
});
