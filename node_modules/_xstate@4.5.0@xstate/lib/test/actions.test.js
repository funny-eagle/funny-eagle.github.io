"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var index_1 = require("../src/index");
var actions_1 = require("../lib/actions");
describe('onEntry/onExit actions', function () {
    var pedestrianStates = {
        initial: 'walk',
        states: {
            walk: {
                on: {
                    PED_COUNTDOWN: 'wait'
                },
                onEntry: 'enter_walk',
                onExit: 'exit_walk'
            },
            wait: {
                on: {
                    PED_COUNTDOWN: 'stop'
                },
                onEntry: 'enter_wait',
                onExit: 'exit_wait'
            },
            stop: {
                onEntry: ['enter_stop'],
                onExit: ['exit_stop']
            }
        }
    };
    var lightMachine = index_1.Machine({
        key: 'light',
        initial: 'green',
        states: {
            green: {
                on: {
                    TIMER: 'yellow',
                    POWER_OUTAGE: 'red',
                    NOTHING: 'green'
                },
                onEntry: 'enter_green',
                onExit: 'exit_green'
            },
            yellow: {
                on: {
                    TIMER: 'red',
                    POWER_OUTAGE: 'red'
                },
                onEntry: 'enter_yellow',
                onExit: 'exit_yellow'
            },
            red: __assign({ on: {
                    TIMER: 'green',
                    POWER_OUTAGE: 'red',
                    NOTHING: 'red'
                }, onEntry: 'enter_red', onExit: 'exit_red' }, pedestrianStates)
        }
    });
    var parallelMachine = index_1.Machine({
        type: 'parallel',
        states: {
            a: {
                initial: 'a1',
                states: {
                    a1: {
                        on: {
                            CHANGE: { target: 'a2', actions: ['do_a2', 'another_do_a2'] }
                        },
                        onEntry: 'enter_a1',
                        onExit: 'exit_a1'
                    },
                    a2: { onEntry: 'enter_a2', onExit: 'exit_a2' }
                },
                onEntry: 'enter_a',
                onExit: 'exit_a'
            },
            b: {
                initial: 'b1',
                states: {
                    b1: {
                        on: { CHANGE: { target: 'b2', actions: 'do_b2' } },
                        onEntry: 'enter_b1',
                        onExit: 'exit_b1'
                    },
                    b2: { onEntry: 'enter_b2', onExit: 'exit_b2' }
                },
                onEntry: 'enter_b',
                onExit: 'exit_b'
            }
        }
    });
    var deepMachine = index_1.Machine({
        initial: 'a',
        states: {
            a: {
                initial: 'a1',
                states: {
                    a1: {
                        on: {
                            NEXT: 'a2',
                            NEXT_FN: 'a3'
                        },
                        onEntry: 'enter_a1',
                        onExit: 'exit_a1'
                    },
                    a2: {
                        onEntry: 'enter_a2',
                        onExit: 'exit_a2'
                    },
                    a3: {
                        on: {
                            NEXT: {
                                target: 'a2',
                                actions: [
                                    function do_a3_to_a2() {
                                        return;
                                    }
                                ]
                            }
                        },
                        onEntry: function enter_a3_fn() {
                            return;
                        },
                        onExit: function exit_a3_fn() {
                            return;
                        }
                    }
                },
                onEntry: 'enter_a',
                onExit: ['exit_a', 'another_exit_a'],
                on: { CHANGE: 'b' }
            },
            b: {
                onEntry: ['enter_b', 'another_enter_b'],
                onExit: 'exit_b',
                initial: 'b1',
                states: {
                    b1: {
                        onEntry: 'enter_b1',
                        onExit: 'exit_b1'
                    }
                }
            }
        }
    });
    var parallelMachine2 = index_1.Machine({
        initial: 'A',
        states: {
            A: {
                on: {
                    'to-B': 'B'
                }
            },
            B: {
                type: 'parallel',
                on: {
                    'to-A': 'A'
                },
                states: {
                    C: {
                        initial: 'C1',
                        states: {
                            C1: {},
                            C2: {}
                        }
                    },
                    D: {
                        initial: 'D1',
                        states: {
                            D1: {
                                on: {
                                    'to-D2': 'D2'
                                }
                            },
                            D2: {
                                onEntry: ['D2 Entry'],
                                onExit: ['D2 Exit']
                            }
                        }
                    }
                }
            }
        }
    });
    describe('State.actions', function () {
        it('should return the entry actions of an initial state', function () {
            chai_1.assert.sameMembers(lightMachine.initialState.actions.map(function (a) { return a.type; }), [
                'enter_green'
            ]);
        });
        it('should return the entry actions of an initial state (deep)', function () {
            chai_1.assert.sameMembers(deepMachine.initialState.actions.map(function (a) { return a.type; }), [
                'enter_a',
                'enter_a1'
            ]);
        });
        it('should return the entry actions of an initial state (parallel)', function () {
            chai_1.assert.sameMembers(parallelMachine.initialState.actions.map(function (a) { return a.type; }), ['enter_a', 'enter_b', 'enter_a1', 'enter_b1']);
        });
        it('should return the entry and exit actions of a transition', function () {
            chai_1.assert.deepEqual(lightMachine.transition('green', 'TIMER').actions.map(function (a) { return a.type; }), ['exit_green', 'enter_yellow']);
        });
        it('should return the entry and exit actions of a deep transition', function () {
            chai_1.assert.deepEqual(lightMachine.transition('yellow', 'TIMER').actions.map(function (a) { return a.type; }), ['exit_yellow', 'enter_red', 'enter_walk']);
        });
        it('should return the entry and exit actions of a nested transition', function () {
            chai_1.assert.deepEqual(lightMachine
                .transition('red.walk', 'PED_COUNTDOWN')
                .actions.map(function (a) { return a.type; }), ['exit_walk', 'enter_wait']);
        });
        it('should not have actions for unhandled events (shallow)', function () {
            chai_1.assert.deepEqual(lightMachine.transition('green', 'FAKE').actions.map(function (a) { return a.type; }), []);
        });
        it('should not have actions for unhandled events (deep)', function () {
            chai_1.assert.deepEqual(lightMachine.transition('red', 'FAKE').actions.map(function (a) { return a.type; }), []);
        });
        it('should exit and enter the state for self-transitions (shallow)', function () {
            chai_1.assert.deepEqual(lightMachine.transition('green', 'NOTHING').actions.map(function (a) { return a.type; }), ['exit_green', 'enter_green']);
        });
        it('should exit and enter the state for self-transitions (deep)', function () {
            // 'red' state resolves to 'red.walk'
            chai_1.assert.deepEqual(lightMachine.transition('red', 'NOTHING').actions.map(function (a) { return a.type; }), ['exit_walk', 'exit_red', 'enter_red', 'enter_walk']);
        });
        it('should return actions for parallel machines', function () {
            chai_1.assert.deepEqual(parallelMachine
                .transition(parallelMachine.initialState, 'CHANGE')
                .actions.map(function (a) { return a.type; }), [
                'exit_a1',
                'exit_b1',
                'do_a2',
                'another_do_a2',
                'do_b2',
                'enter_a2',
                'enter_b2'
            ]);
        });
        it('should return nested actions in the correct (child to parent) order', function () {
            chai_1.assert.deepEqual(deepMachine.transition('a.a1', 'CHANGE').actions.map(function (a) { return a.type; }), [
                'exit_a1',
                'exit_a',
                'another_exit_a',
                'enter_b',
                'another_enter_b',
                'enter_b1'
            ]);
        });
        it('should ignore parent state actions for same-parent substates', function () {
            chai_1.assert.deepEqual(deepMachine.transition('a.a1', 'NEXT').actions.map(function (a) { return a.type; }), ['exit_a1', 'enter_a2']);
        });
        it('should work with function actions', function () {
            chai_1.assert.deepEqual(deepMachine
                .transition(deepMachine.initialState, 'NEXT_FN')
                .actions.map(function (action) { return action.type; }), ['exit_a1', 'enter_a3_fn']);
            chai_1.assert.deepEqual(deepMachine
                .transition('a.a3', 'NEXT')
                .actions.map(function (action) { return action.type; }), ['exit_a3_fn', 'do_a3_to_a2', 'enter_a2']);
        });
        it('should exit children of parallel state nodes', function () {
            var stateB = parallelMachine2.transition(parallelMachine2.initialState, 'to-B');
            var stateD2 = parallelMachine2.transition(stateB, 'to-D2');
            var stateA = parallelMachine2.transition(stateD2, 'to-A');
            chai_1.assert.deepEqual(stateA.actions.map(function (action) { return action.type; }), ['D2 Exit']);
        });
        describe('should ignore same-parent state actions (sparse)', function () {
            var fooBar = {
                initial: 'foo',
                states: {
                    foo: {
                        on: {
                            TACK: 'bar',
                            ABSOLUTE_TACK: '#machine.ping.bar'
                        }
                    },
                    bar: {
                        on: {
                            TACK: 'foo'
                        }
                    }
                }
            };
            var pingPong = index_1.Machine({
                initial: 'ping',
                key: 'machine',
                states: {
                    ping: __assign({ onEntry: ['entryEvent'], on: {
                            TICK: 'pong'
                        } }, fooBar),
                    pong: {
                        on: {
                            TICK: 'ping'
                        }
                    }
                }
            });
            it('with a relative transition', function () {
                chai_1.assert.isEmpty(pingPong.transition('ping.foo', 'TACK').actions);
            });
            it('with an absolute transition', function () {
                chai_1.assert.isEmpty(pingPong.transition('ping.foo', 'ABSOLUTE_TACK').actions);
            });
        });
    });
});
describe('actions on invalid transition', function () {
    var stopMachine = index_1.Machine({
        initial: 'idle',
        states: {
            idle: {
                on: {
                    STOP: {
                        target: 'stop',
                        actions: ['action1']
                    }
                }
            },
            stop: {}
        }
    });
    it('should not recall previous actions', function () {
        var nextState = stopMachine.transition('idle', 'STOP');
        chai_1.assert.isEmpty(stopMachine.transition(nextState, 'INVALID').actions);
    });
});
describe('actions option', function () {
    // tslint:disable-next-line:no-empty
    var definedAction = function () { };
    var simpleMachine = index_1.Machine({
        initial: 'a',
        context: {
            count: 0
        },
        states: {
            a: {
                onEntry: [
                    'definedAction',
                    { type: 'definedAction' },
                    'undefinedAction'
                ],
                on: {
                    EVENT: {
                        target: 'b',
                        actions: [{ type: 'definedAction' }, { type: 'updateContext' }]
                    }
                }
            },
            b: {}
        },
        on: {
            E: 'a'
        }
    }, {
        actions: {
            definedAction: definedAction,
            updateContext: actions_1.assign({ count: 10 })
        }
    });
    it('should reference actions defined in actions parameter of machine options', function () {
        var initialState = simpleMachine.initialState;
        var nextState = simpleMachine.transition(initialState, 'E');
        chai_1.assert.includeMembers(nextState.actions.map(function (a) { return a.type; }), [
            'definedAction',
            'undefinedAction'
        ]);
        chai_1.assert.deepEqual(nextState.actions, [
            { type: 'definedAction', exec: definedAction },
            { type: 'definedAction', exec: definedAction },
            { type: 'undefinedAction', exec: undefined }
        ]);
    });
    it('should reference actions defined in actions parameter of machine options (initial state)', function () {
        var initialState = simpleMachine.initialState;
        chai_1.assert.includeMembers(initialState.actions.map(function (a) { return a.type; }), [
            'definedAction',
            'undefinedAction'
        ]);
    });
    it('should be able to reference action implementations from action objects', function () {
        var state = simpleMachine.transition('a', 'EVENT');
        chai_1.assert.deepEqual(state.actions, [
            { type: 'definedAction', exec: definedAction }
        ]);
        chai_1.assert.deepEqual(state.context, { count: 10 });
    });
});
