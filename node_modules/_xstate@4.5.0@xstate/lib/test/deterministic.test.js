"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var Machine_1 = require("../src/Machine");
describe('deterministic machine', function () {
    var pedestrianStates = {
        initial: 'walk',
        states: {
            walk: {
                on: {
                    PED_COUNTDOWN: 'wait',
                    TIMER: undefined // forbidden event
                }
            },
            wait: {
                on: {
                    PED_COUNTDOWN: 'stop',
                    TIMER: undefined // forbidden event
                }
            },
            stop: {}
        }
    };
    var lightMachine = Machine_1.Machine({
        key: 'light',
        initial: 'green',
        states: {
            green: {
                on: {
                    TIMER: 'yellow',
                    POWER_OUTAGE: 'red'
                }
            },
            yellow: {
                on: {
                    TIMER: 'red',
                    POWER_OUTAGE: 'red'
                }
            },
            red: __assign({ on: {
                    TIMER: 'green',
                    POWER_OUTAGE: 'red'
                } }, pedestrianStates)
        }
    });
    var testMachine = Machine_1.Machine({
        key: 'test',
        initial: 'a',
        states: {
            a: {
                on: {
                    T: 'b.b1',
                    F: 'c'
                }
            },
            b: {
                initial: 'b1',
                states: {
                    b1: {}
                }
            }
        }
    });
    var deepMachine = Machine_1.Machine({
        key: 'deep',
        initial: 'a',
        states: {
            a1: {
                initial: 'a2',
                states: {
                    a2: {
                        initial: 'a3',
                        states: {
                            a3: {
                                initial: 'a4',
                                states: {
                                    a4: {}
                                }
                            }
                        }
                    }
                }
            }
        }
    });
    describe('machine.initialState', function () {
        it('should return the initial state value', function () {
            chai_1.assert.deepEqual(lightMachine.initialState.value, 'green');
        });
        it('should not have any history', function () {
            chai_1.assert.isUndefined(lightMachine.initialState.history);
        });
    });
    describe('machine.transition()', function () {
        it('should properly transition states based on string event', function () {
            chai_1.assert.deepEqual(lightMachine.transition('green', 'TIMER').value, 'yellow');
        });
        it('should properly transition states based on event-like object', function () {
            var event = {
                type: 'TIMER'
            };
            chai_1.assert.deepEqual(lightMachine.transition('green', event).value, 'yellow');
        });
        it('should not transition states for illegal transitions', function () {
            chai_1.assert.equal(lightMachine.transition('green', 'FAKE').value, 'green');
            chai_1.assert.isEmpty(lightMachine.transition('green', 'FAKE').actions);
        });
        it('should throw an error if not given an event', function () {
            // @ts-ignore
            chai_1.assert.throws(function () { return lightMachine.transition('red', undefined); });
        });
        it('should transition to nested states as target', function () {
            chai_1.assert.deepEqual(testMachine.transition('a', 'T').value, { b: 'b1' });
        });
        it('should throw an error for transitions from invalid states', function () {
            chai_1.assert.throws(function () { return testMachine.transition('fake', 'T'); });
        });
        it('should throw an error for transitions to invalid states', function () {
            chai_1.assert.throws(function () { return testMachine.transition('a', 'F'); });
        });
        it('should throw an error for transitions from invalid substates', function () {
            chai_1.assert.throws(function () { return testMachine.transition('a.fake', 'T'); });
        });
    });
    describe('machine.transition() with nested states', function () {
        it('should properly transition a nested state', function () {
            chai_1.assert.deepEqual(lightMachine.transition('red.walk', 'PED_COUNTDOWN').value, { red: 'wait' });
        });
        it('should transition from initial nested states', function () {
            chai_1.assert.deepEqual(lightMachine.transition('red', 'PED_COUNTDOWN').value, {
                red: 'wait'
            });
        });
        it('should transition from deep initial nested states', function () {
            chai_1.assert.deepEqual(lightMachine.transition('red', 'PED_COUNTDOWN').value, {
                red: 'wait'
            });
        });
        it('should bubble up events that nested states cannot handle', function () {
            chai_1.assert.equal(lightMachine.transition('red.stop', 'TIMER').value, 'green');
        });
        it('should not transition from illegal events', function () {
            chai_1.assert.deepEqual(lightMachine.transition('red.walk', 'FAKE').value, {
                red: 'walk'
            });
            chai_1.assert.isEmpty(lightMachine.transition('red.walk', 'FAKE').actions);
            chai_1.assert.deepEqual(deepMachine.transition('a1', 'FAKE').value, {
                a1: { a2: { a3: 'a4' } }
            });
            chai_1.assert.isEmpty(deepMachine.transition('a1', 'FAKE').actions);
        });
        it('should transition to the deepest initial state', function () {
            chai_1.assert.deepEqual(lightMachine.transition('yellow', 'TIMER').value, {
                red: 'walk'
            });
        });
        it('should return the equivalent state if no transition occurs', function () {
            var initialState = lightMachine.transition(lightMachine.initialState, 'NOTHING');
            var nextState = lightMachine.transition(initialState, 'NOTHING');
            chai_1.assert.equal(initialState.value, nextState.value);
            chai_1.assert.isFalse(nextState.changed);
        });
    });
    describe('state key names', function () {
        var machine = Machine_1.Machine({
            key: 'test',
            initial: 'test',
            states: {
                test: {
                    activities: ['activity'],
                    onEntry: ['onEntry'],
                    on: {
                        NEXT: 'test'
                    },
                    onExit: ['onExit']
                }
            }
        });
        it('should work with substate nodes that have the same key', function () {
            chai_1.assert.deepEqual(machine.transition(machine.initialState, 'NEXT').value, 'test');
        });
    });
    describe('forbidden events', function () {
        it('undefined transitions should forbid events', function () {
            var walkState = lightMachine.transition('red.walk', 'TIMER');
            chai_1.assert.deepEqual(walkState.value, { red: 'walk' }, 'Machine should not transition to "green" when in "red.walk"');
        });
    });
});
