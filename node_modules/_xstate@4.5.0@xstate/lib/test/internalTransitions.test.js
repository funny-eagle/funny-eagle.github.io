"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../src/index");
var chai_1 = require("chai");
var wordMachine = index_1.Machine({
    key: 'word',
    type: 'parallel',
    states: {
        direction: {
            initial: 'left',
            onEntry: 'ENTER_DIRECTION',
            onExit: 'EXIT_DIRECTION',
            states: {
                left: {},
                right: {},
                center: {},
                justify: {}
            },
            on: {
                // internal transitions
                LEFT_CLICK: '.left',
                RIGHT_CLICK: '.right',
                CENTER_CLICK: '.center',
                JUSTIFY_CLICK: '.justify',
                RESET: 'direction',
                RESET_TO_CENTER: 'direction.center'
            }
        }
    }
});
var topLevelMachine = index_1.Machine({
    initial: 'Hidden',
    on: {
        CLICKED_CLOSE: '.Hidden',
        TARGETLESS_ARRAY: [{ actions: ['doSomethingParent'] }],
        TARGETLESS_OBJECT: { actions: ['doSomethingParent'] },
        PARENT_EVENT: { actions: ['handleParentEvent'] }
    },
    states: {
        Hidden: {
            on: {
                PUBLISH_FAILURE: 'Failure',
                TARGETLESS_ARRAY: [{ actions: ['doSomething'] }],
                TARGETLESS_OBJECT: { actions: ['doSomething'] }
            }
        },
        Failure: {}
    }
});
describe('internal transitions', function () {
    it('parent state should enter child state without re-entering self', function () {
        var nextState = wordMachine.transition(wordMachine.initialState, 'RIGHT_CLICK');
        chai_1.assert.deepEqual(nextState.value, { direction: 'right' });
        chai_1.assert.lengthOf(nextState.actions.map(function (a) { return a.type; }), 0, 'should not have onEntry or onExit actions');
    });
    it('parent state should only exit/reenter if there is an explicit self-transition', function () {
        var resetState = wordMachine.transition('direction.center', 'RESET');
        chai_1.assert.deepEqual(resetState.value, { direction: 'left' });
        chai_1.assert.deepEqual(resetState.actions.map(function (a) { return a.type; }), [
            'EXIT_DIRECTION',
            'ENTER_DIRECTION'
        ]);
    });
    it('parent state should only exit/reenter if there is an explicit self-transition (to child)', function () {
        var resetState = wordMachine.transition('direction.right', 'RESET_TO_CENTER');
        chai_1.assert.deepEqual(resetState.value, { direction: 'center' });
        chai_1.assert.deepEqual(resetState.actions.map(function (a) { return a.type; }), [
            'EXIT_DIRECTION',
            'ENTER_DIRECTION'
        ]);
    });
    it('should listen to events declared at top state', function () {
        var actualState = topLevelMachine.transition('Failure', 'CLICKED_CLOSE');
        chai_1.assert.deepEqual(actualState.value, 'Hidden');
    });
    it('should work with targetless transitions (in conditional array)', function () {
        var sameState = topLevelMachine.transition('Hidden', 'TARGETLESS_ARRAY');
        chai_1.assert.deepEqual(sameState.actions.map(function (a) { return a.type; }), ['doSomething']);
    });
    it('should work with targetless transitions (in object)', function () {
        var sameState = topLevelMachine.transition('Hidden', 'TARGETLESS_OBJECT');
        chai_1.assert.deepEqual(sameState.actions.map(function (a) { return a.type; }), ['doSomething']);
    });
    it('should work on parent with targetless transitions (in conditional array)', function () {
        var sameState = topLevelMachine.transition('Failure', 'TARGETLESS_ARRAY');
        chai_1.assert.deepEqual(sameState.actions.map(function (a) { return a.type; }), ['doSomethingParent']);
    });
    it('should work with targetless transitions (in object)', function () {
        var sameState = topLevelMachine.transition('Failure', 'TARGETLESS_OBJECT');
        chai_1.assert.deepEqual(sameState.actions.map(function (a) { return a.type; }), ['doSomethingParent']);
    });
    it('should maintain the child state when targetless transition is handled by parent', function () {
        var hiddenState = topLevelMachine.transition('Hidden', 'PARENT_EVENT');
        chai_1.assert.deepEqual(hiddenState.value, 'Hidden');
    });
});
