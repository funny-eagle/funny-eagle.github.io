"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../src/index");
var interpreter_1 = require("../src/interpreter");
var actions_1 = require("../src/actions");
var chai_1 = require("chai");
var childMachine = index_1.Machine({
    id: 'child',
    initial: 'init',
    states: {
        init: {
            onEntry: [index_1.actions.sendParent('INC'), index_1.actions.sendParent('INC')],
            on: {
                FORWARD_DEC: {
                    actions: [
                        index_1.actions.sendParent('DEC'),
                        index_1.actions.sendParent('DEC'),
                        index_1.actions.sendParent('DEC')
                    ]
                }
            }
        }
    }
});
var parentMachine = index_1.Machine({
    id: 'parent',
    context: { count: 0 },
    initial: 'start',
    states: {
        start: {
            invoke: {
                src: 'child',
                id: 'someService',
                forward: true
            },
            on: {
                INC: { actions: actions_1.assign({ count: function (ctx) { return ctx.count + 1; } }) },
                DEC: { actions: actions_1.assign({ count: function (ctx) { return ctx.count - 1; } }) },
                FORWARD_DEC: undefined,
                STOP: 'stop'
            }
        },
        stop: {}
    }
}, {
    services: {
        child: childMachine
    }
});
var user = { name: 'David' };
var fetchMachine = index_1.Machine({
    id: 'fetch',
    context: {
        userId: undefined
    },
    initial: 'pending',
    states: {
        pending: {
            onEntry: actions_1.send({ type: 'RESOLVE', user: user }),
            on: {
                RESOLVE: {
                    target: 'success',
                    cond: function (ctx) { return ctx.userId !== undefined; }
                }
            }
        },
        success: {
            type: 'final',
            data: { user: function (_, e) { return e.user; } }
        },
        failure: {
            onEntry: actions_1.sendParent('REJECT')
        }
    }
});
var fetcherMachine = index_1.Machine({
    id: 'fetcher',
    initial: 'idle',
    context: {
        selectedUserId: '42',
        user: undefined
    },
    states: {
        idle: {
            on: {
                GO_TO_WAITING: 'waiting',
                GO_TO_WAITING_MACHINE: 'waitingInvokeMachine'
            }
        },
        waiting: {
            invoke: {
                src: fetchMachine,
                data: {
                    userId: function (ctx) { return ctx.selectedUserId; }
                },
                onDone: {
                    target: 'received',
                    cond: function (_, e) {
                        // Should receive { user: { name: 'David' } } as event data
                        return e.data.user.name === 'David';
                    }
                }
            }
        },
        waitingInvokeMachine: {
            invoke: {
                src: fetchMachine.withContext({ userId: '55' }),
                onDone: 'received'
            }
        },
        received: {
            type: 'final'
        }
    }
});
// @ts-ignore
var intervalMachine = index_1.Machine({
    id: 'interval',
    initial: 'counting',
    context: {
        interval: 10,
        count: 0
    },
    states: {
        counting: {
            invoke: {
                id: 'intervalService',
                src: function (ctx) { return function (cb) {
                    var interval = setInterval(function () {
                        cb('INC');
                    }, ctx.interval);
                    return function () { return clearInterval(interval); };
                }; }
            },
            on: {
                '': {
                    target: 'finished',
                    cond: function (ctx) { return ctx.count === 3; }
                },
                INC: { actions: actions_1.assign({ count: function (ctx) { return ctx.count + 1; } }) },
                SKIP: 'wait'
            }
        },
        wait: {
            on: {
                // this should never be called if interval service is properly disposed
                INC: { actions: actions_1.assign({ count: function (ctx) { return ctx.count + 1; } }) }
            },
            after: {
                50: 'finished'
            }
        },
        finished: {
            type: 'final'
        }
    }
});
describe('invoke', function () {
    it('should start services (external machines)', function () {
        var service = interpreter_1.interpret(parentMachine).start();
        // 1. The 'parent' machine will enter 'start' state
        // 2. The 'child' service will be run with ID 'someService'
        // 3. The 'child' machine will enter 'init' state
        // 4. The 'onEntry' action will be executed, which sends 'INC' to 'parent' machine twice
        // 5. The context will be updated to increment count to 2
        chai_1.assert.deepEqual(service.state.context, { count: 2 });
    });
    it('should forward events to services if forward: true', function () {
        var service = interpreter_1.interpret(parentMachine).start();
        service.send('FORWARD_DEC');
        // 1. The 'parent' machine will not do anything (inert transition)
        // 2. The 'FORWARD_DEC' event will be forwarded to the 'child' machine (forward: true)
        // 3. On the 'child' machine, the 'FORWARD_DEC' event sends the 'DEC' action to the 'parent' thrice
        // 4. The context of the 'parent' machine will be updated from 2 to -1
        chai_1.assert.deepEqual(service.state.context, { count: -1 });
    });
    it('should start services (explicit machine, invoke = config)', function (done) {
        interpreter_1.interpret(fetcherMachine)
            .onDone(function () {
            done();
        })
            .start()
            .send('GO_TO_WAITING');
    });
    it('should start services (explicit machine, invoke = machine)', function (done) {
        interpreter_1.interpret(fetcherMachine)
            .onDone(function (_) {
            done();
        })
            .start()
            .send('GO_TO_WAITING_MACHINE');
    });
    it('should use the service overwritten by withConfig', function () {
        var service = interpreter_1.interpret(parentMachine.withConfig({
            services: {
                child: index_1.Machine({
                    id: 'child',
                    initial: 'init',
                    states: {
                        init: {
                            onEntry: [index_1.actions.sendParent('STOP')]
                        }
                    }
                })
            }
        })).start();
        chai_1.assert.deepEqual(service.state.value, 'stop');
    });
    describe('parent to child', function () {
        var subMachine = index_1.Machine({
            id: 'child',
            initial: 'one',
            states: {
                one: {
                    on: { NEXT: 'two' }
                },
                two: {
                    onEntry: actions_1.sendParent('NEXT')
                }
            }
        });
        // console.dir(mainMachine.activities, { depth: null });
        it('should communicate with the child machine (invoke on machine)', function (done) {
            var mainMachine = index_1.Machine({
                id: 'parent',
                initial: 'one',
                invoke: {
                    id: 'foo-child',
                    src: subMachine
                },
                states: {
                    one: {
                        onEntry: actions_1.send('NEXT', { to: 'foo-child' }),
                        on: { NEXT: 'two' }
                    },
                    two: {
                        type: 'final'
                    }
                }
            });
            interpreter_1.interpret(mainMachine)
                .onDone(function () {
                done();
            })
                .start();
        });
        it('should communicate with the child machine (invoke on created machine)', function (done) {
            var mainMachine = index_1.Machine({
                id: 'parent',
                initial: 'one',
                context: {
                    machine: subMachine
                },
                invoke: {
                    id: 'foo-child',
                    src: function (ctx) { return ctx.machine; }
                },
                states: {
                    one: {
                        onEntry: actions_1.send('NEXT', { to: 'foo-child' }),
                        on: { NEXT: 'two' }
                    },
                    two: {
                        type: 'final'
                    }
                }
            });
            interpreter_1.interpret(mainMachine)
                .onDone(function () {
                done();
            })
                .start();
        });
        it('should communicate with the child machine (invoke on state)', function (done) {
            var mainMachine = index_1.Machine({
                id: 'parent',
                initial: 'one',
                states: {
                    one: {
                        invoke: {
                            id: 'foo-child',
                            src: subMachine
                        },
                        onEntry: actions_1.send('NEXT', { to: 'foo-child' }),
                        on: { NEXT: 'two' }
                    },
                    two: {
                        type: 'final'
                    }
                }
            });
            interpreter_1.interpret(mainMachine)
                .onDone(function () {
                done();
            })
                .start();
        });
    });
    describe('with promises', function () {
        var invokePromiseMachine = index_1.Machine({
            id: 'invokePromise',
            initial: 'pending',
            context: {
                id: 42,
                succeed: true
            },
            states: {
                pending: {
                    invoke: {
                        src: function (ctx) {
                            return new Promise(function (resolve) {
                                if (ctx.succeed) {
                                    resolve(ctx.id);
                                }
                                else {
                                    throw new Error("failed on purpose for: " + ctx.id);
                                }
                            });
                        },
                        onDone: {
                            target: 'success',
                            cond: function (ctx, e) {
                                return e.data === ctx.id;
                            }
                        },
                        onError: 'failure'
                    }
                },
                success: {
                    type: 'final'
                },
                failure: {
                    type: 'final'
                }
            }
        });
        it('should be invoked with a promise factory and resolve through onDone', function (done) {
            interpreter_1.interpret(invokePromiseMachine)
                .onDone(function () { return done(); })
                .start();
        });
        it('should be invoked with a promise factory and reject with ErrorExecution', function (done) {
            interpreter_1.interpret(invokePromiseMachine.withContext({ id: 31, succeed: false }))
                .onDone(function () { return done(); })
                .start();
        });
        it('should be able to specify a Promise as a service', function (done) {
            var promiseMachine = index_1.Machine({
                id: 'promise',
                initial: 'pending',
                context: { foo: true },
                states: {
                    pending: {
                        on: { BEGIN: 'first' }
                    },
                    first: {
                        invoke: {
                            src: 'somePromise',
                            onDone: 'last'
                        }
                    },
                    last: {
                        type: 'final'
                    }
                }
            }, {
                services: {
                    somePromise: function (ctx, e) {
                        return new Promise(function (res, rej) {
                            ctx.foo && e.payload ? res() : rej();
                        });
                    }
                }
            });
            interpreter_1.interpret(promiseMachine)
                .onDone(function () { return done(); })
                .start()
                .send({ type: 'BEGIN', payload: true });
        });
        it('should be able to specify a callback as a service', function (done) {
            var callbackMachine = index_1.Machine({
                id: 'callback',
                initial: 'pending',
                context: { foo: true },
                states: {
                    pending: {
                        on: { BEGIN: 'first' }
                    },
                    first: {
                        invoke: {
                            src: 'someCallback'
                        },
                        on: {
                            CALLBACK: {
                                target: 'last',
                                cond: function (_, e) { return e.data === 42; }
                            }
                        }
                    },
                    last: {
                        type: 'final'
                    }
                }
            }, {
                services: {
                    someCallback: function (ctx, e) { return function (cb) {
                        if (ctx.foo && e.payload) {
                            cb({ type: 'CALLBACK', data: 40 });
                            cb({ type: 'CALLBACK', data: 41 });
                            cb({ type: 'CALLBACK', data: 42 });
                        }
                    }; }
                }
            });
            interpreter_1.interpret(callbackMachine)
                .onDone(function () { return done(); })
                .start()
                .send({ type: 'BEGIN', payload: true });
        });
    });
    describe('with callbacks', function () {
        it('should treat a callback source as an event stream', function (done) {
            interpreter_1.interpret(intervalMachine)
                .onDone(function () { return done(); })
                .start();
        });
        it('should dispose of the callback (if disposal function provided)', function (done) {
            var service = interpreter_1.interpret(intervalMachine)
                .onDone(function () {
                // if intervalService isn't disposed after skipping, 'INC' event will
                // keep being sent
                chai_1.assert.equal(service.state.context.count, 0, 'should exit interval service before the first event is sent');
                done();
            })
                .start();
            // waits 50 milliseconds before going to final state.
            service.send('SKIP');
        });
        it('callback should be able to receive messages from parent', function (done) {
            var pingPongMachine = index_1.Machine({
                id: 'ping-pong',
                initial: 'active',
                states: {
                    active: {
                        invoke: {
                            id: 'child',
                            src: function () { return function (next, onEvent) {
                                onEvent(function (e) {
                                    if (e.type === 'PING') {
                                        next('PONG');
                                    }
                                });
                            }; }
                        },
                        onEntry: actions_1.send('PING', { to: 'child' }),
                        on: {
                            PONG: 'done'
                        }
                    },
                    done: {
                        type: 'final'
                    }
                }
            });
            interpreter_1.interpret(pingPongMachine)
                .onDone(function () { return done(); })
                .start();
        });
    });
});
