var __assign = this && this.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = this && this.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = this && this.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = this && this.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
import { SpecialTargets, ActionTypes } from './types';
import { State } from './State';
import * as actionTypes from './actionTypes';
import { toEventObject, doneInvoke, error } from './actions';
import { IS_PRODUCTION } from './StateNode';
import { isPromiseLike, mapContext, bindActionToState, warn, keys, isArray, isFunction, isString } from './utils';
import { Scheduler } from './scheduler';
var SimulatedClock = /** @class */ /*#__PURE__*/function () {
    function SimulatedClock() {
        this.timeouts = new Map();
        this._now = 0;
        this._id = 0;
    }
    SimulatedClock.prototype.now = function () {
        return this._now;
    };
    SimulatedClock.prototype.getId = function () {
        return this._id++;
    };
    SimulatedClock.prototype.setTimeout = function (fn, timeout) {
        var id = this.getId();
        this.timeouts.set(id, {
            start: this.now(),
            timeout: timeout,
            fn: fn
        });
        return id;
    };
    SimulatedClock.prototype.clearTimeout = function (id) {
        this.timeouts.delete(id);
    };
    SimulatedClock.prototype.set = function (time) {
        if (this._now > time) {
            throw new Error('Unable to travel back in time');
        }
        this._now = time;
        this.flushTimeouts();
    };
    SimulatedClock.prototype.flushTimeouts = function () {
        var _this = this;
        this.timeouts.forEach(function (timeout, id) {
            if (_this.now() - timeout.start >= timeout.timeout) {
                timeout.fn.call(null);
                _this.timeouts.delete(id);
            }
        });
    };
    SimulatedClock.prototype.increment = function (ms) {
        this._now += ms;
        this.flushTimeouts();
    };
    return SimulatedClock;
}();
export { SimulatedClock };
var Interpreter = /** @class */ /*#__PURE__*/function () {
    /**
     * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
     *
     * @param machine The machine to be interpreted
     * @param options Interpreter options
     */
    function Interpreter(machine, options) {
        if (options === void 0) {
            options = Interpreter.defaultOptions;
        }
        var _this = this;
        this.machine = machine;
        this.scheduler = new Scheduler();
        this.delayedEventsMap = {};
        this.listeners = new Set();
        this.contextListeners = new Set();
        this.stopListeners = new Set();
        this.doneListeners = new Set();
        this.eventListeners = new Set();
        this.sendListeners = new Set();
        this.initialized = false;
        this.children = new Map();
        this.forwardTo = new Set();
        /**
         * Alias for Interpreter.prototype.start
         */
        this.init = this.start;
        /**
         * Sends an event to the running interpreter to trigger a transition.
         *
         * An array of events (batched) can be sent as well, which will send all
         * batched events to the running interpreter. The listeners will be
         * notified only **once** when all events are processed.
         *
         * @param event The event(s) to send
         */
        this.send = function (event, payload) {
            if (isArray(event)) {
                _this.batch(event);
                return _this.state;
            }
            var eventObject = toEventObject(event, payload);
            if (!_this.initialized && _this.options.deferEvents) {
                // tslint:disable-next-line:no-console
                warn(false, "Event \"" + eventObject.type + "\" was sent to uninitialized service \"" + _this.machine.id + "\" and is deferred. Make sure .start() is called for this service.\nEvent: " + JSON.stringify(event));
            } else if (!_this.initialized) {
                throw new Error("Event \"" + eventObject.type + "\" was sent to uninitialized service \"" + _this.machine.id + "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: " + JSON.stringify(eventObject));
            }
            _this.scheduler.schedule(function () {
                var nextState = _this.nextState(eventObject);
                _this.update(nextState, eventObject);
                // Forward copy of event to child interpreters
                _this.forward(eventObject);
            });
            return _this.state; // TODO: deprecate (should return void)
            // tslint:disable-next-line:semicolon
        };
        /**
         * Returns a send function bound to this interpreter instance.
         *
         * @param event The event to be sent by the sender.
         */
        this.sender = function (event) {
            function sender() {
                return this.send(event);
            }
            return sender.bind(_this);
        };
        this.sendTo = function (event, to) {
            var isParent = to === SpecialTargets.Parent;
            var target = isParent ? _this.parent : _this.children.get(to);
            if (!target) {
                if (!isParent) {
                    throw new Error("Unable to send event to child '" + to + "' from service '" + _this.id + "'.");
                }
                // tslint:disable-next-line:no-console
                warn(false, "Service '" + _this.id + "' has no parent: unable to send event " + event.type);
                return;
            }
            target.send(event);
        };
        var resolvedOptions = __assign({}, Interpreter.defaultOptions, options);
        var clock = resolvedOptions.clock,
            logger = resolvedOptions.logger,
            parent = resolvedOptions.parent,
            id = resolvedOptions.id;
        var resolvedId = id !== undefined ? id : machine.id;
        Object.assign(this, {
            clock: clock,
            logger: logger,
            parent: parent,
            id: resolvedId
        });
        this.options = resolvedOptions;
        this.scheduler = new Scheduler({
            deferEvents: this.options.deferEvents
        });
    }
    Object.defineProperty(Interpreter.prototype, "initialState", {
        /**
         * The initial state of the statechart.
         */
        get: function () {
            return this.machine.initialState;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Executes the actions of the given state, with that state's `context` and `event`.
     *
     * @param state The state whose actions will be executed
     */
    Interpreter.prototype.execute = function (state) {
        var e_1, _a;
        try {
            for (var _b = __values(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
                var action = _c.value;
                this.exec(action, state.context, state.event);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Interpreter.prototype.update = function (state, event) {
        var e_2, _a, e_3, _b, e_4, _c, e_5, _d;
        // Update state
        this.state = state;
        // Execute actions
        if (this.options.execute) {
            this.execute(this.state);
        }
        // Dev tools
        if (this.devTools) {
            this.devTools.send(event, state);
        }
        // Execute listeners
        if (state.event) {
            try {
                for (var _e = __values(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var listener = _f.value;
                    listener(state.event);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
        }
        try {
            for (var _g = __values(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {
                var listener = _h.value;
                listener(state, state.event);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        try {
            for (var _j = __values(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {
                var contextListener = _k.value;
                contextListener(this.state.context, this.state.history ? this.state.history.context : undefined);
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        if (this.state.tree && this.state.tree.done) {
            // get donedata
            var doneData = this.state.tree.getDoneData(this.state.context, toEventObject(event));
            try {
                for (var _l = __values(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var listener = _m.value;
                    listener(doneInvoke(this.id, doneData));
                }
            } catch (e_5_1) {
                e_5 = { error: e_5_1 };
            } finally {
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                } finally {
                    if (e_5) throw e_5.error;
                }
            }
            this.stop();
        }
    };
    /*
     * Adds a listener that is notified whenever a state transition happens. The listener is called with
     * the next state and the event object that caused the state transition.
     *
     * @param listener The state listener
     */
    Interpreter.prototype.onTransition = function (listener) {
        this.listeners.add(listener);
        return this;
    };
    /**
     * Adds an event listener that is notified whenever an event is sent to the running interpreter.
     * @param listener The event listener
     */
    Interpreter.prototype.onEvent = function (listener) {
        this.eventListeners.add(listener);
        return this;
    };
    /**
     * Adds an event listener that is notified whenever a `send` event occurs.
     * @param listener The event listener
     */
    Interpreter.prototype.onSend = function (listener) {
        this.sendListeners.add(listener);
        return this;
    };
    /**
     * Adds a context listener that is notified whenever the state context changes.
     * @param listener The context listener
     */
    Interpreter.prototype.onChange = function (listener) {
        this.contextListeners.add(listener);
        return this;
    };
    /**
     * Adds a listener that is notified when the machine is stopped.
     * @param listener The listener
     */
    Interpreter.prototype.onStop = function (listener) {
        this.stopListeners.add(listener);
        return this;
    };
    /**
     * Adds a state listener that is notified when the statechart has reached its final state.
     * @param listener The state listener
     */
    Interpreter.prototype.onDone = function (listener) {
        this.doneListeners.add(listener);
        return this;
    };
    /**
     * Removes a listener.
     * @param listener The listener to remove
     */
    Interpreter.prototype.off = function (listener) {
        this.listeners.delete(listener);
        this.eventListeners.delete(listener);
        this.sendListeners.delete(listener);
        this.stopListeners.delete(listener);
        this.doneListeners.delete(listener);
        this.contextListeners.delete(listener);
        return this;
    };
    /**
     * Starts the interpreter from the given state, or the initial state.
     * @param initialState The state to start the statechart from
     */
    Interpreter.prototype.start = function (initialState) {
        var _this = this;
        var resolvedState = initialState === undefined ? this.machine.initialState : initialState instanceof State ? this.machine.resolveState(initialState) : this.machine.resolveState(State.from(initialState));
        this.initialized = true;
        if (this.options.devTools) {
            this.attachDev();
        }
        this.scheduler.initialize(function () {
            _this.update(resolvedState, { type: actionTypes.init });
        });
        return this;
    };
    /**
     * Stops the interpreter and unsubscribe all listeners.
     *
     * This will also notify the `onStop` listeners.
     */
    Interpreter.prototype.stop = function () {
        var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;
        try {
            for (var _f = __values(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {
                var listener = _g.value;
                this.listeners.delete(listener);
            }
        } catch (e_6_1) {
            e_6 = { error: e_6_1 };
        } finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            } finally {
                if (e_6) throw e_6.error;
            }
        }
        try {
            for (var _h = __values(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {
                var listener = _j.value;
                // call listener, then remove
                listener();
                this.stopListeners.delete(listener);
            }
        } catch (e_7_1) {
            e_7 = { error: e_7_1 };
        } finally {
            try {
                if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
            } finally {
                if (e_7) throw e_7.error;
            }
        }
        try {
            for (var _k = __values(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {
                var listener = _l.value;
                this.contextListeners.delete(listener);
            }
        } catch (e_8_1) {
            e_8 = { error: e_8_1 };
        } finally {
            try {
                if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
            } finally {
                if (e_8) throw e_8.error;
            }
        }
        try {
            for (var _m = __values(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {
                var listener = _o.value;
                this.doneListeners.delete(listener);
            }
        } catch (e_9_1) {
            e_9 = { error: e_9_1 };
        } finally {
            try {
                if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
            } finally {
                if (e_9) throw e_9.error;
            }
        }
        // Stop all children
        this.children.forEach(function (child) {
            if (isFunction(child.stop)) {
                child.stop();
            }
        });
        try {
            // Cancel all delayed events
            for (var _p = __values(keys(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {
                var key = _q.value;
                this.clock.clearTimeout(this.delayedEventsMap[key]);
            }
        } catch (e_10_1) {
            e_10 = { error: e_10_1 };
        } finally {
            try {
                if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
            } finally {
                if (e_10) throw e_10.error;
            }
        }
        this.initialized = false;
        return this;
    };
    Interpreter.prototype.batch = function (events) {
        var _this = this;
        if (!this.initialized && this.options.deferEvents) {
            // tslint:disable-next-line:no-console
            warn(false, events.length + " event(s) were sent to uninitialized service \"" + this.machine.id + "\" and are deferred. Make sure .start() is called for this service.\nEvent: " + JSON.stringify(event));
        } else if (!this.initialized) {
            throw new Error(events.length + " event(s) were sent to uninitialized service \"" + this.machine.id + "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.");
        }
        this.scheduler.schedule(function () {
            var e_11, _a, _b;
            var nextState = _this.state;
            try {
                for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
                    var event_1 = events_1_1.value;
                    var eventObject = toEventObject(event_1);
                    var actions = nextState.actions.map(function (a) {
                        return bindActionToState(a, nextState);
                    });
                    nextState = _this.machine.transition(nextState, eventObject);
                    (_b = nextState.actions).unshift.apply(_b, __spread(actions));
                    _this.forward(eventObject);
                }
            } catch (e_11_1) {
                e_11 = { error: e_11_1 };
            } finally {
                try {
                    if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
                } finally {
                    if (e_11) throw e_11.error;
                }
            }
            _this.update(nextState, toEventObject(events[events.length - 1]));
        });
    };
    /**
     * Returns the next state given the interpreter's current state and the event.
     *
     * This is a pure method that does _not_ update the interpreter's state.
     *
     * @param event The event to determine the next state
     */
    Interpreter.prototype.nextState = function (event) {
        var eventObject = toEventObject(event);
        if (eventObject.type === actionTypes.errorExecution && this.state.nextEvents.indexOf(actionTypes.errorExecution) === -1) {
            throw eventObject.data;
        }
        var nextState = this.machine.transition(this.state, eventObject, this.state.context);
        return nextState;
    };
    Interpreter.prototype.forward = function (event) {
        var e_12, _a;
        try {
            for (var _b = __values(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {
                var id = _c.value;
                var child = this.children.get(id);
                if (!child) {
                    throw new Error("Unable to forward event '" + event + "' from interpreter '" + this.id + "' to nonexistant child '" + id + "'.");
                }
                child.send(event);
            }
        } catch (e_12_1) {
            e_12 = { error: e_12_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_12) throw e_12.error;
            }
        }
    };
    Interpreter.prototype.defer = function (sendAction) {
        var _this = this;
        var delay = sendAction.delay;
        if (isString(delay)) {
            if (!this.machine.options.delays || this.machine.options.delays[delay] === undefined) {
                // tslint:disable-next-line:no-console
                warn(false, "No delay reference for delay expression '" + delay + "' was found on machine '" + this.machine.id + "' on service '" + this.id + "'.");
                // Do not send anything
                return;
            } else {
                var delayExpr = this.machine.options.delays[delay];
                delay = typeof delayExpr === 'number' ? delayExpr : delayExpr(this.state.context, this.state.event);
            }
        }
        this.delayedEventsMap[sendAction.id] = this.clock.setTimeout(function () {
            if (sendAction.to) {
                _this.sendTo(sendAction.event, sendAction.to);
            } else {
                _this.send(sendAction.event);
            }
        }, delay || 0);
    };
    Interpreter.prototype.cancel = function (sendId) {
        this.clock.clearTimeout(this.delayedEventsMap[sendId]);
        delete this.delayedEventsMap[sendId];
    };
    Interpreter.prototype.exec = function (action, context, event) {
        if (action.exec) {
            return action.exec(context, event, { action: action, state: this.state });
        }
        switch (action.type) {
            case actionTypes.send:
                var sendAction = action;
                if (sendAction.delay) {
                    this.defer(sendAction);
                    return;
                } else {
                    if (sendAction.to) {
                        this.sendTo(sendAction.event, sendAction.to);
                    } else {
                        this.send(sendAction.event);
                    }
                }
                break;
            case actionTypes.cancel:
                this.cancel(action.sendId);
                break;
            case actionTypes.start:
                {
                    var activity = action.activity;
                    // If the activity will be stopped right after it's started
                    // (such as in transient states)
                    // don't bother starting the activity.
                    if (!this.state.activities[activity.type]) {
                        break;
                    }
                    // Invoked services
                    if (activity.type === ActionTypes.Invoke) {
                        var serviceCreator = this.machine.options.services ? this.machine.options.services[activity.src] : undefined;
                        var id = activity.id,
                            data = activity.data;
                        var autoForward = !!activity.forward;
                        if (!serviceCreator) {
                            // tslint:disable-next-line:no-console
                            warn(false, "No service found for invocation '" + activity.src + "' in machine '" + this.machine.id + "'.");
                            return;
                        }
                        var source = isFunction(serviceCreator) ? serviceCreator(context, event) : serviceCreator;
                        if (isPromiseLike(source)) {
                            this.spawnPromise(id, Promise.resolve(source));
                        } else if (isFunction(source)) {
                            this.spawnCallback(id, source);
                        } else if (typeof source !== 'string') {
                            // TODO: try/catch here
                            this.spawn(data ? source.withContext(mapContext(data, context, event)) : source, {
                                id: id,
                                autoForward: autoForward
                            });
                        } else {
                            // service is string
                        }
                    } else {
                        this.spawnActivity(activity);
                    }
                    break;
                }
            case actionTypes.stop:
                {
                    this.stopChild(action.activity.id);
                    break;
                }
            case actionTypes.log:
                var expr = action.expr ? action.expr(context, event) : undefined;
                if (action.label) {
                    this.logger(action.label, expr);
                } else {
                    this.logger(expr);
                }
                break;
            default:
                warn(false, "No implementation found for action type '" + action.type + "'");
                break;
        }
        return undefined;
    };
    Interpreter.prototype.stopChild = function (childId) {
        var child = this.children.get(childId);
        if (child && isFunction(child.stop)) {
            child.stop();
            this.children.delete(childId);
            this.forwardTo.delete(childId);
        }
    };
    Interpreter.prototype.spawn = function (machine, options) {
        var _this = this;
        if (options === void 0) {
            options = {};
        }
        var childService = new Interpreter(machine, {
            parent: this,
            id: options.id || machine.id
        });
        childService.onDone(function (doneEvent) {
            _this.send(doneEvent); // todo: fix
        }).start();
        this.children.set(childService.id, childService);
        if (options.autoForward) {
            this.forwardTo.add(childService.id);
        }
        return childService;
    };
    Interpreter.prototype.spawnPromise = function (id, promise) {
        var _this = this;
        var canceled = false;
        promise.then(function (response) {
            if (!canceled) {
                _this.send(doneInvoke(id, response));
            }
        }).catch(function (errorData) {
            if (!canceled) {
                var errorEvent = error(errorData, id);
                try {
                    // Send "error.execution" to this (parent).
                    _this.send(errorEvent);
                } catch (error) {
                    if (!IS_PRODUCTION) {
                        _this.reportUnhandledExceptionOnInvocation(errorData, error, id);
                    }
                    if (_this.devTools) {
                        _this.devTools.send(errorEvent, _this.state);
                    }
                    if (_this.machine.strict) {
                        // it would be better to always stop the state machine if unhandled
                        // exception/promise rejection happens but because we don't want to
                        // break existing code so enforce it on strict mode only especially so
                        // because documentation says that onError is optional
                        _this.stop();
                    }
                }
            }
        });
        this.children.set(id, {
            send: function () {
                return void 0;
            },
            stop: function () {
                canceled = true;
            }
        });
    };
    Interpreter.prototype.spawnCallback = function (id, callback) {
        var _this = this;
        var receive = function (e) {
            return _this.send(e);
        };
        var listener = function (e) {
            warn(false, "Event '" + e.type + "' sent to callback service '" + id + "' but was not handled by a listener.");
        };
        var stop;
        try {
            stop = callback(receive, function (newListener) {
                listener = newListener;
            });
            if (isPromiseLike(stop)) {
                Promise.resolve(stop).catch(function (e) {
                    var errorEvent = error(e, id);
                    try {
                        _this.send(errorEvent);
                    } catch (error) {
                        if (!IS_PRODUCTION) {
                            _this.reportUnhandledExceptionOnInvocation(e, error, id);
                        }
                        if (_this.devTools) {
                            _this.devTools.send(errorEvent, _this.state);
                        }
                        if (_this.machine.strict) {
                            // it would be better to always stop the state machine if unhandled
                            // exception/promise rejection happens but because we don't want to
                            // break existing code so enforce it on strict mode only especially so
                            // because documentation says that onError is optional
                            _this.stop();
                        }
                    }
                });
            }
        } catch (e) {
            this.send(error(e, id));
        }
        this.children.set(id, {
            send: listener,
            stop: stop
        });
    };
    Interpreter.prototype.spawnActivity = function (activity) {
        var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : undefined;
        if (!implementation) {
            // tslint:disable-next-line:no-console
            warn(false, "No implementation found for activity '" + activity.type + "'");
            return;
        }
        // Start implementation
        var dispose = implementation(this.state.context, activity);
        this.spawnEffect(activity.id, dispose);
    };
    Interpreter.prototype.spawnEffect = function (id, dispose) {
        this.children.set(id, {
            send: function () {
                return void 0;
            },
            stop: dispose
        });
    };
    Interpreter.prototype.reportUnhandledExceptionOnInvocation = function (originalError, currentError, id) {
        var originalStackTrace = originalError.stack ? " Stacktrace was '" + originalError.stack + "'" : '';
        if (originalError === currentError) {
            // tslint:disable-next-line:no-console
            console.error("Missing onError handler for invocation '" + id + "', error was '" + originalError + "'." + originalStackTrace);
        } else {
            var stackTrace = currentError.stack ? " Stacktrace was '" + currentError.stack + "'" : '';
            // tslint:disable-next-line:no-console
            console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '" + id + "'. " + ("Original error: '" + originalError + "'. " + originalStackTrace + " Current error is '" + currentError + "'." + stackTrace));
        }
    };
    Interpreter.prototype.attachDev = function () {
        if (this.options.devTools && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__) {
            this.devTools = window.__REDUX_DEVTOOLS_EXTENSION__.connect({
                name: this.id,
                features: {
                    jump: false,
                    skip: false
                }
            });
            this.devTools.init(this.state);
        }
    };
    /**
     * The default interpreter options:
     *
     * - `clock` uses the global `setTimeout` and `clearTimeout` functions
     * - `logger` uses the global `console.log()` method
     */
    Interpreter.defaultOptions = /*#__PURE__*/function (global) {
        return {
            execute: true,
            deferEvents: true,
            clock: {
                setTimeout: function (fn, ms) {
                    return global.setTimeout.call(null, fn, ms);
                },
                clearTimeout: function (id) {
                    return global.clearTimeout.call(null, id);
                }
            },
            logger: global.console.log.bind(console),
            devTools: false
        };
    }(typeof window === 'undefined' ? global : window);
    Interpreter.interpret = interpret;
    return Interpreter;
}();
export { Interpreter };
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */
export function interpret(machine, options) {
    var interpreter = new Interpreter(machine, options);
    return interpreter;
}