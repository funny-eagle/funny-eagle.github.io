var t,e;!function(t){t.Start="xstate.start",t.Stop="xstate.stop",t.Raise="xstate.raise",t.Send="xstate.send",t.Cancel="xstate.cancel",t.NullEvent="",t.Assign="xstate.assign",t.After="xstate.after",t.DoneState="done.state",t.DoneInvoke="done.invoke",t.Log="xstate.log",t.Init="xstate.init",t.Invoke="xstate.invoke",t.ErrorExecution="error.execution",t.ErrorCommunication="error.communication"}(t||(t={})),function(t){t.Parent="#_parent",t.Internal="#_internal"}(e||(e={}));const i=".",s={};function n(t,e){var i={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(i[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(s=Object.getOwnPropertySymbols(t);n<s.length;n++)e.indexOf(s[n])<0&&(i[s[n]]=t[s[n]])}return i}class o{constructor(t){this.actions=[],this.activities=s,this.meta={},this.events=[],this.value=t.value,this.context=t.context,this.event=t.event,this.historyValue=t.historyValue,this.history=t.history,this.actions=t.actions||[],this.activities=t.activities||s,this.meta=t.meta||{},this.events=t.events||[],Object.defineProperty(this,"tree",{value:t.tree,enumerable:!1})}static from(e,i){if(e instanceof o)return e.context!==i?new o({value:e.value,context:i,event:e.event,historyValue:e.historyValue,history:e.history,actions:[],activities:e.activities,meta:{},events:[],tree:e.tree}):e;const s={type:t.Init};return new o({value:e,context:i,event:s,historyValue:void 0,history:void 0,actions:[],activities:void 0,meta:void 0,events:[]})}static create(t){return new o(t)}static inert(e,i){if(e instanceof o){if(!e.actions.length)return e;const s={type:t.Init};return new o({value:e.value,context:i,event:s,historyValue:e.historyValue,history:e.history,activities:e.activities,tree:e.tree})}return o.from(e,i)}get inert(){return o.inert(this,this.context)}get nextEvents(){return this.tree?this.tree.nextEvents:[]}toStrings(t=this.value,e="."){if(lt(t))return[t];const i=q(t);return i.concat(...i.map(i=>this.toStrings(t[i]).map(t=>i+e+t)))}matches(t){return B(t,this.value)}}const r=t.Start,a=t.Stop,h=t.Raise,c=t.Send,d=t.Cancel,l=t.NullEvent,u=t.Assign,f=(t.After,t.DoneState,t.Log),p=t.Init,v=t.Invoke,y=t.ErrorExecution,g={type:p};function m(t,e){if(lt(t)||"number"==typeof t){const i={type:t};return e&&Object.assign(i,e),i}return t}function S(t,e){if(!e)return;const i=e[t];return i?(dt(i),i):void 0}function w(t,e){let i;if(lt(t)||"number"==typeof t){const s=S(t,e);i=dt(s)?{type:t,exec:s}:s||{type:t,exec:void 0}}else if(dt(t))i={type:t.name||t.toString(),exec:t};else{const s=S(t.type,e);if(dt(s))i=Object.assign({},t,{exec:s});else if(s){const{type:e}=t,o=n(t,["type"]);i=Object.assign({type:e},s,o)}else i=t}return Object.defineProperty(i,"toString",{value:()=>i.type,enumerable:!1,configurable:!0}),i}function x(t){const e=w(t);return Object.assign({id:lt(t)?t:e.id},e,{type:e.type})}function E(t){return{type:h,event:t}}function N(t,e){return{to:e?e.to:void 0,type:c,event:dt(t)?t:m(t),delay:e?e.delay:void 0,id:e&&void 0!==e.id?e.id:dt(t)?t.name:X(t)}}function b(t,i){return N(t,Object.assign({},i,{to:e.Parent}))}const $=t=>({type:d,sendId:t});function O(e){const i=x(e);return{type:t.Start,activity:i,exec:void 0}}function k(e){const i=x(e);return{type:t.Stop,activity:i,exec:void 0}}const T=t=>({type:u,assignment:t});function j(e,i){const s=i?`#${i}`:"";return`${t.After}(${e})${s}`}function V(e,i){const s=`${t.DoneState}.${e}`,n={type:s,data:i,toString:()=>s};return n}function _(e,i){const s=`${t.DoneInvoke}.${e}`,n={type:s,data:i,toString:()=>s};return n}function I(e,i){return{src:i,type:t.ErrorExecution,data:e}}const L={resolved:!1};class D{constructor(t,e,i=L){this.stateNode=t,this.stateValue=e,this.nodes=e?lt(e)?{[e]:new D(t.getStateNode(e),void 0)}:Q(e,(e,i)=>new D(t.getStateNode(i),e)):{};const s=Object.assign({},L,i);this.isResolved=s.resolved}get done(){switch(this.stateNode.type){case"final":return!0;case"compound":return"final"===this.nodes[q(this.nodes)[0]].stateNode.type;case"parallel":return q(this.nodes).every(t=>this.nodes[t].done);default:return!1}}getDoneData(t,e){if(this.done&&"compound"===this.stateNode.type){const i=this.nodes[q(this.nodes)[0]];if(!i.stateNode.data)return;return it(i.stateNode.data,t,e)}}get atomicNodes(){return"atomic"===this.stateNode.type||"final"===this.stateNode.type?[this.stateNode]:tt(q(this.value).map(t=>this.value[t].atomicNodes))}getDoneEvents(t){if(!t||!t.size)return[];if(t.has(this.stateNode)&&"final"===this.stateNode.type)return[V(this.stateNode.id,this.stateNode.data)];const e=tt(q(this.nodes).map(e=>this.nodes[e].getDoneEvents(t)));if("parallel"===this.stateNode.type){const t=q(this.nodes).every(t=>this.nodes[t].done);return e&&t?e.concat(V(this.stateNode.id)):e}if(!this.done||!e.length)return e;const i=1===e.length?e[0].data:void 0;return e.concat(V(this.stateNode.id,i))}get resolved(){return new D(this.stateNode,this.stateNode.resolve(this.value),{resolved:!0})}get paths(){return Z(this.value)}get absolute(){const{stateValue:t}=this,e={};let i=e;for(let e=0;e<this.stateNode.path.length;e++){const s=this.stateNode.path[e];e===this.stateNode.path.length-1?i[s]=t:(i[s]={},i=i[s])}return new D(this.stateNode.machine,e)}get nextEvents(){const t=this.stateNode.ownEvents,e=tt(q(this.nodes).map(t=>{return this.nodes[t].nextEvents}));return[...new Set(e.concat(t))]}clone(){return new D(this.stateNode,this.value)}combine(t){if(t.stateNode!==this.stateNode)throw new Error("Cannot combine distinct trees");if("compound"===this.stateNode.type){let e;if(q(this.nodes).length&&q(t.nodes).length){const i=q(this.nodes)[0];e={[i]:this.nodes[i].combine(t.nodes[i])};const s=this.clone();return s.nodes=e,s}{e=Object.assign({},this.nodes,t.nodes);const i=this.clone();return i.nodes=e,i}}if("parallel"===this.stateNode.type){const e=new Set([...q(this.nodes),...q(t.nodes)]),i={};for(const s of e)this.nodes[s]&&t.nodes[s]?i[s]=this.nodes[s].combine(t.nodes[s]):i[s]=this.nodes[s]||t.nodes[s];const s=this.clone();return s.nodes=i,s}return this}get value(){if("atomic"===this.stateNode.type||"final"===this.stateNode.type)return{};if("parallel"===this.stateNode.type)return Q(this.nodes,t=>t.value);if("compound"===this.stateNode.type){if(0===q(this.nodes).length)return{};const t=this.nodes[q(this.nodes)[0]].stateNode;return"atomic"===t.type||"final"===t.type?t.key:Q(this.nodes,t=>t.value)}return{}}matches(t){return B(t,this.value)}getEntryExitStates(t,e){if(t.stateNode!==this.stateNode)throw new Error("Cannot compare distinct trees");switch(this.stateNode.type){case"compound":let i={exit:[],entry:[]};const s=q(this.nodes)[0],n=q(t.nodes)[0];return s!==n?(i.exit=t.nodes[n].getExitStates(),i.entry=this.nodes[s].getEntryStates()):i=this.nodes[s].getEntryExitStates(t.nodes[n],e),e&&e.has(this.stateNode)&&(i.exit.push(this.stateNode),i.entry.unshift(this.stateNode)),i;case"parallel":const o=q(this.nodes).map(i=>this.nodes[i].getEntryExitStates(t.nodes[i],e)),r={exit:[],entry:[]};for(const t of o)r.exit=[...r.exit,...t.exit],r.entry=[...r.entry,...t.entry];return e&&e.has(this.stateNode)&&(r.exit.push(this.stateNode),r.entry.unshift(this.stateNode)),r;case"atomic":default:return e&&e.has(this.stateNode)?{exit:[this.stateNode],entry:[this.stateNode]}:{exit:[],entry:[]}}}getEntryStates(){return this.nodes?[this.stateNode].concat(tt(q(this.nodes).map(t=>this.nodes[t].getEntryStates()))):[this.stateNode]}getExitStates(){return this.nodes?tt(q(this.nodes).map(t=>this.nodes[t].getExitStates())).concat(this.stateNode):[this.stateNode]}}const P=".",C="",M="#",z="",A={},R=t=>t[0]===M,F=()=>({actions:{},guards:{},services:{},activities:{},delays:{},updater:rt});class G{constructor(t,e,i){this._config=t,this.context=i,this.__cache={events:void 0,relativeValue:new Map,initialState:void 0},this.idMap={},this.options=Object.assign({},F(),e),this.key=t.key||t.id||"(machine)",this.parent=t.parent,this.machine=this.parent?this.parent.machine:this,this.path=this.parent?this.parent.path.concat(this.key):[],this.delimiter=t.delimiter||(this.parent?this.parent.delimiter:P),this.id=t.id||(this.machine?[this.machine.key,...this.path].join(this.delimiter):this.key),this.version=this.parent?this.parent.version:t.version,this.type=t.type||(t.parallel?"parallel":t.states&&q(t.states).length?"compound":t.history?"history":"atomic"),ht(!("parallel"in t),`The "parallel" property is deprecated and will be removed in version 4.1. ${t.parallel?"Replace with `type: 'parallel'`":`Use \`type: '${this.type}'\``} in the config for state node '${this.id}' instead.`),this.initial=t.initial,this.order=t.order||-1,this.states=t.states?Q(t.states,(t,e,i,s)=>{const n=new G(Object.assign({},t,{key:e,order:void 0===t.order?s:t.order,parent:this}));return Object.assign(this.idMap,Object.assign({[n.id]:n},n.idMap)),n}):A,this.history=!0===t.history?"shallow":t.history||!1,this.transient=!(!t.on||!t.on[C]),this.strict=!!t.strict,this.onEntry=et(t.entry||t.onEntry).map(t=>w(t)),this.onExit=et(t.exit||t.onExit).map(t=>w(t)),this.meta=t.meta,this.data="final"===this.type?t.data:void 0,this.invoke=et(t.invoke).map((t,e)=>{if(t instanceof G)return(this.parent||this).options.services=Object.assign({[t.id]:t},(this.parent||this).options.services),{type:v,src:t.id,id:t.id};if("string"!=typeof t.src){const i=`${this.id}:invocation[${e}]`;return this.machine.options.services=Object.assign({[i]:t.src},this.machine.options.services),Object.assign({type:v,id:i},t,{src:i})}return Object.assign({},t,{type:v,id:t.id||t.src,src:t.src})}),this.activities=et(t.activities).concat(this.invoke).map(t=>x(t)),this.after=this.getDelayedTransitions()}withConfig(t,e=this.context){const{actions:i,activities:s,guards:n,services:o,delays:r}=this.options;return new G(this.definition,{actions:Object.assign({},i,t.actions),activities:Object.assign({},s,t.activities),guards:Object.assign({},n,t.guards),services:Object.assign({},o,t.services),delays:Object.assign({},r,t.delays)},e)}withContext(t){return new G(this.definition,this.options,t)}get definition(){return{id:this.id,key:this.key,version:this.version,type:this.type,initial:this.initial,history:this.history,states:Q(this.states,t=>t.definition),on:this.on,onEntry:this.onEntry,onExit:this.onExit,activities:this.activities||[],meta:this.meta,order:this.order||-1,data:this.data}}get config(){return n(this._config,["parent"])}get on(){return this.formatTransitions()}get transitions(){return tt(q(this.on).map(t=>this.on[t]))}getDelayedTransitions(){if(this.after)return this.after;const t=this.config.after;if(!t)return[];if(ct(t))return t.map((t,e)=>{const{delay:i}=t;let s;dt(i)?(s=`${this.id}:delay[${e}]`,this.options.delays[s]=i):s=i;const n=j(s,this.id);return this.onEntry.push(N(n,{delay:i})),this.onExit.push($(n)),Object.assign({event:n},t,{cond:t.cond?this.toGuard(t.cond):void 0,actions:et(t.actions).map(t=>w(t))})});const e=tt(q(t).map(e=>{const i=t[e],s=isNaN(+e)?e:+e,n=j(s,this.id);return this.onEntry.push(N(n,{delay:s})),this.onExit.push($(n)),lt(i)?[{target:i,delay:s,event:n,actions:[]}]:et(i).map(t=>Object.assign({event:n,delay:s},t,{cond:t.cond?this.toGuard(t.cond):void 0,actions:et(t.actions).map(t=>w(t))}))}));return e.sort((t,e)=>lt(t)||lt(e)?0:+t.delay-+e.delay),e}getStateNodes(t){if(!t)return[];const e=t instanceof o?t.value:J(t,this.delimiter);if(lt(e)){const t=this.getStateNode(e).initial;return void 0!==t?this.getStateNodes({[e]:t}):[this.states[e]]}const i=q(e);return i.map(t=>this.getStateNode(t)).concat(i.reduce((t,i)=>{const s=this.getStateNode(i).getStateNodes(e[i]);return t.concat(s)},[]))}handles(t){const e=X(t);return-1!==this.events.indexOf(e)}resolveState(t){const e=this.getStateTree(t.value),i=this.resolve(t.value);return new o({value:i,context:t.context,event:t.event,historyValue:t.historyValue,history:t.history,actions:t.actions,activities:t.activities,meta:t.meta,events:t.events,tree:e})}transitionLeafNode(t,e,i){const s=this.getStateNode(t).next(e,i);if(!s.tree){const{reentryStates:t,actions:s,tree:n}=this.next(e,i);return{tree:n,source:e,reentryStates:t,actions:s}}return s}transitionCompoundNode(t,e,i){const s=q(t),n=this.getStateNode(s[0])._transition(t[s[0]],e,i);if(!n.tree){const{reentryStates:t,actions:s,tree:n}=this.next(e,i);return{tree:n,source:e,reentryStates:t,actions:s}}return n}transitionParallelNode(t,e,i){const s={};for(const n of q(t)){const o=t[n];if(!o)continue;const r=this.getStateNode(n)._transition(o,e,i);r.tree,s[n]=r}if(!q(s).some(t=>void 0!==s[t].tree)){const{reentryStates:t,actions:s,tree:n}=this.next(e,i);return{tree:n,source:e,reentryStates:t,actions:s}}const n=q(s).map(t=>s[t].tree).filter(t=>void 0!==t).reduce((t,e)=>t.combine(e));return 1!==n.paths.length||B(J(this.path,this.delimiter),n.value)?{tree:q(s).map(t=>{const i=s[t],n=Y(this.path)(i.tree?i.tree.value:e.value||e.value)[t];return new D(this.getStateNode(t),n).absolute}).reduce((t,e)=>t.combine(e)),source:e,reentryStates:q(s).reduce((t,e)=>{const{tree:i,reentryStates:n}=s[e];return i&&n?new Set([...Array.from(t),...Array.from(n)]):t},new Set),actions:tt(q(s).map(t=>s[t].actions))}:{tree:n,source:e,reentryStates:q(s).map(t=>s[t].reentryStates).reduce((t,e)=>{if(!e)return t;for(const i of e)t.add(i);return t},new Set),actions:tt(q(s).map(t=>s[t].actions))}}_transition(t,e,i){return lt(t)?this.transitionLeafNode(t,e,i):1===q(t).length?this.transitionCompoundNode(t,e,i):this.transitionParallelNode(t,e,i)}next(t,e){const i=e.type,s=this.on[i],n=this.transient?[{type:l}]:[];if(!s||!s.length)return{tree:void 0,source:t,reentryStates:void 0,actions:n};let o,r=[];for(const i of s){const{cond:s,in:a}=i,h=t.context,c=!a||(lt(a)&&R(a)?t.matches(J(this.getStateNodeById(a).path,this.delimiter)):B(J(a,this.delimiter),Y(this.path.slice(0,-2))(t.value)));if((!s||this.evaluateGuard(s,h,e,t))&&c){r=et(i.target),n.push(...et(i.actions)),o=i;break}}if(o&&0===r.length){return{tree:t.value?this.machine.getStateTree(t.value):void 0,source:t,reentryStates:void 0,actions:n}}if(!o&&0===r.length)return{tree:void 0,source:t,reentryStates:void 0,actions:n};const a=tt(r.map(e=>this.getRelativeStateNodes(e,t.historyValue))),h=!!o.internal?[]:tt(a.map(t=>this.nodesFromChild(t)));return{tree:a.map(t=>t.tree).reduce((t,e)=>t.combine(e)),source:t,reentryStates:new Set(h),actions:n}}get tree(){const t=J(this.path,this.delimiter);return new D(this.machine,t)}nodesFromChild(t){if(t.escapes(this))return[];const e=[];let i=t;for(;i&&i!==this;)e.push(i),i=i.parent;return e.push(this),e}getStateTree(t){return new D(this,t)}escapes(t){if(this===t)return!1;let e=this.parent;for(;e;){if(e===t)return!1;e=e.parent}return!0}evaluateGuard(t,e,i,s){let n;const{guards:o}=this.machine.options,r={state:s,cond:t};if("xstate.cond"===t.type)return t.predicate(e,i,r);if(!o[t.type])throw new Error(`Guard (condition) '${t.type}' is not implemented on machine '${this.machine.id}'.`);return(n=o[t.type])(e,i,r)}toGuard(t){return lt(t)?{type:t}:dt(t)?{type:"xstate.cond",predicate:t}:t}getActions(t,e){const i=t.tree?t.tree.resolved.getEntryExitStates(this.getStateTree(e.value),t.reentryStates?t.reentryStates:void 0):{entry:[],exit:[]},s=t.tree?t.tree.getDoneEvents(new Set(i.entry)):[];t.source||(i.exit=[],i.entry.unshift(this));const n=new Set(i.entry),o=new Set(i.exit),[r,a]=[tt(Array.from(n).map(t=>[...t.activities.map(t=>O(t)),...t.onEntry])).concat(s.map(E)),tt(Array.from(o).map(t=>[...t.onExit,...t.activities.map(t=>k(t))]))];return a.concat(t.actions).concat(r).map(t=>w(t,this.machine.options.actions))}transition(e,i,s){let n;if(e instanceof o)n=void 0===s?e:this.resolveState(o.from(e,s));else{const t=lt(e)?this.resolve(K(this.getResolvedPath(e))):this.resolve(e),i=s||this.machine.context;n=this.resolveState(o.from(t,i))}const r=m(i),a=r.type;if(this.strict&&-1===this.events.indexOf(a)&&!function(e){if(0===e.indexOf(t.DoneState)||0===e.indexOf(t.DoneInvoke))return!0;if(e===t.ErrorCommunication||e===t.ErrorCommunication)return!0;return!1}(a))throw new Error(`Machine '${this.id}' does not accept event '${a}'`);const h=this._transition(n.value,n,r),c=Object.assign({},h,{tree:h.tree?h.tree.resolved:void 0});return this.resolveTransition(c,n,r)}resolveTransition(e,i,s){const n=e.tree?e.tree.value:void 0,d=i.historyValue?i.historyValue:e.source?this.machine.historyValue(i.value):void 0,f=this.getActions(e,i),p=Object.assign({},i.activities);for(const t of f)t.type===r?p[t.activity.type]=t:t.type===a&&(p[t.activity.type]=!1);const[v,y]=nt(f,t=>t.type===h||t.type===l),[S,x]=nt(y,t=>t.type===u),E=S.length?this.options.updater(i.context,s,S):i.context,N=x.map(e=>{const i=w(e);if(i.type===c){const e=function(t,e,i){const s=dt(t.event)?m(t.event(e,i)):m(t.event),n=dt(t.delay)?t.delay(e,i):t.delay;return Object.assign({},t,{event:s,delay:n})}(i,E,s||{type:t.Init});if(lt(e.delay)){if(!this.machine.options.delays||void 0===this.machine.options.delays[e.delay])return ht(!1,`No delay reference for delay expression '${e.delay}' was found on machine '${this.machine.id}'`),e;const i=this.machine.options.delays[e.delay];e.delay="number"==typeof i?i:i(E,s||{type:t.Init})}return e}return w(i,this.options.actions)}),b=n?this.getStateNodes(n):[];b.some(t=>t.transient)&&v.push({type:l});const $=[this,...b].reduce((t,e)=>(void 0!==e.meta&&(t[e.id]=e.meta),t),{});let O=n?new o({value:n,context:E,event:s||g,historyValue:d?(k=d,T=n,{current:T,states:ot(k,T)}):void 0,history:e.source?i:void 0,actions:N,activities:p,meta:$,events:v,tree:e.tree}):void 0;var k,T;if(!O)return(O=new o({value:i.value,context:E,event:s,historyValue:i.historyValue,history:i,actions:[],activities:i.activities,meta:i.meta,events:[],tree:i.tree})).changed=!!S.length,O;const{history:j}=O;j&&delete j.history;let V=O;for(;v.length;){const t=V.actions,e=v.shift();(V=this.transition(V,e.type===l?C:e.event,V.context)).event=s,V.actions.unshift(...t)}const _=j?!!V.actions.length||!!S.length||typeof j.value!=typeof V.value||!function t(e,i){if(e===i)return!0;if(void 0===e||void 0===i)return!1;if(lt("string"===e||typeof i))return e===i;const s=q(e),n=q(i);return s.length===n.length&&s.every(s=>t(e[s],i[s]))}(V.value,j.value):void 0;return V.changed=_,V.historyValue=O.historyValue,V.history=j,V}ensureValidPaths(t){const e=new Map,i=tt(t.map(t=>this.getRelativeStateNodes(t)));t:for(const t of i){let i=t;for(;i.parent;){if(e.has(i.parent)){if("parallel"===i.parent.type)continue t;throw new Error(`State node '${t.id}' shares parent '${i.parent.id}' with state node '${e.get(i.parent).map(t=>t.id)}'`)}e.get(i.parent)?e.get(i.parent).push(t):e.set(i.parent,[t]),i=i.parent}}}getStateNode(t){if(R(t))return this.machine.getStateNodeById(t);if(!this.states)throw new Error(`Unable to retrieve child state '${t}' from '${this.id}'; no child states exist.`);const e=this.states[t];if(!e)throw new Error(`Child state '${t}' does not exist on '${this.id}'`);return e}getStateNodeById(t){const e=R(t)?t.slice(M.length):t;if(e===this.id)return this;const i=this.machine.idMap[e];if(!i)throw new Error(`Substate '#${e}' does not exist on '${this.id}'`);return i}getStateNodeByPath(t){const e=H(t,this.delimiter).slice();let i=this;for(;e.length;){const t=e.shift();i=i.getStateNode(t)}return i}resolve(t){if(!t)return this.initialStateValue||A;switch(this.type){case"parallel":return Q(this.initialStateValue,(e,i)=>e?this.getStateNode(i).resolve(t[i]||e):A);case"compound":if(lt(t)){const e=this.getStateNode(t);return"parallel"===e.type||"compound"===e.type?{[t]:e.initialStateValue}:t}return q(t).length?Q(t,(t,e)=>t?this.getStateNode(e).resolve(t):A):this.initialStateValue||{};default:return t||A}}get resolvedStateValue(){const{key:t}=this;if("parallel"===this.type)return{[t]:W(this.states,t=>t.resolvedStateValue[t.key],t=>!("history"===t.type))};if(void 0===this.initial)return t;if(!this.states[this.initial])throw new Error(`Initial state '${this.initial}' not found on '${t}'`);return{[t]:this.states[this.initial].resolvedStateValue}}getResolvedPath(t){if(R(t)){const e=this.machine.idMap[t.slice(M.length)];if(!e)throw new Error(`Unable to find state node '${t}'`);return e.path}return H(t,this.delimiter)}get initialStateValue(){if(this.__cache.initialState)return this.__cache.initialState;const t="parallel"===this.type?W(this.states,t=>t.initialStateValue||A,t=>!("history"===t.type)):lt(this.resolvedStateValue)?void 0:this.resolvedStateValue[this.key];return this.__cache.initialState=t,this.__cache.initialState}getInitialState(e,i=this.machine.context){const s={},n=[];for(const t of this.getStateNodes(e))if(t.onEntry&&n.push(...t.onEntry),t.activities)for(const e of t.activities)s[X(e)]=e,n.push(O(e));const r=n.filter(t=>"object"==typeof t&&t.type===u),a=this.options.updater(i,{type:t.Init},r);return new o({value:e,context:a,event:g,activities:s})}get initialState(){const{initialStateValue:e}=this;if(!e)throw new Error(`Cannot retrieve initial state from simple state '${this.id}'.`);const i=this.getInitialState(e);return this.resolveTransition({tree:this.getStateTree(e),source:void 0,reentryStates:new Set(this.getStateNodes(e)),actions:[]},i,{type:t.Init})}get target(){let t;if("history"===this.type){const e=this.config;t=e.target&&lt(e.target)&&R(e.target)?K(this.machine.getStateNodeById(e.target).path.slice(this.path.length-1)):e.target}return t}getStates(t){if(lt(t))return[this.states[t]];const e=[];for(const i of q(t))e.push(...this.states[i].getStates(t[i]));return e}getRelativeStateNodes(t,e,i=!0){if(lt(t)&&R(t)){const s=this.getStateNodeById(t);return i?"history"===s.type?s.resolveHistory(e):s.initialStateNodes:[s]}const s=H(t,this.delimiter),n=(this.parent||this).getFromRelativePath(s,e);return i?tt(n.map(t=>t.initialStateNodes)):n}get initialStateNodes(){if("atomic"===this.type||"final"===this.type)return[this];if("compound"===this.type&&!this.initial)return ht(!1,`Compound state node '${this.id}' has no initial state.`),[this];return tt(Z(this.initialStateValue).map(t=>this.getFromRelativePath(t)))}getFromRelativePath(t,e){if(!t.length)return[this];const[i,...s]=t;if(!this.states)throw new Error(`Cannot retrieve subPath '${i}' from node with no states`);const n=this.getStateNode(i);if("history"===n.type)return n.resolveHistory(e);if(!this.states[i])throw new Error(`Child state '${i}' does not exist on '${this.id}'`);return this.states[i].getFromRelativePath(s,e)}historyValue(t){if(q(this.states).length)return{current:t||this.initialStateValue,states:W(this.states,(e,i)=>{if(!t)return e.historyValue();const s=lt(t)?void 0:t[i];return e.historyValue(s||e.initialStateValue)},t=>!t.history)}}resolveHistory(t){if("history"!==this.type)return[this];const e=this.parent;if(!t)return this.target?tt(Z(this.target).map(t=>e.getFromRelativePath(t))):e.initialStateNodes;const i=(s=e.path,n="states",t=>{let e=t;for(const t of s)e=e[n][t];return e})(t).current;var s,n;return lt(i)?[e.getStateNode(i)]:tt(Z(i).map(t=>"deep"===this.history?e.getFromRelativePath(t):[e.states[t[0]]]))}get stateIds(){const t=tt(q(this.states).map(t=>this.states[t].stateIds));return[this.id].concat(t)}get events(){if(this.__cache.events)return this.__cache.events;const{states:t}=this,e=new Set(this.ownEvents);if(t)for(const i of q(t)){const s=t[i];if(s.states)for(const t of s.events)e.add(`${t}`)}return this.__cache.events=Array.from(e)}get ownEvents(){const t=new Set(q(this.on).filter(t=>{return this.on[t].some(t=>!(!t.target&&!t.actions.length&&t.internal))}));return Array.from(t)}formatTransition(t,e,i){let s=e?e.internal:void 0;if(void 0===t||t===z)return Object.assign({},e,{actions:e?et(e.actions).map(t=>w(t)):[],cond:e&&e.cond?this.toGuard(e.cond):void 0,target:void 0,internal:void 0===s||s,event:i});const n=et(t).map(t=>{if(t instanceof G)return`#${t.id}`;const e=lt(t)&&t[0]===this.delimiter;return s=void 0===s?e:s,e&&!this.parent?t.slice(1):e?this.key+t:`${t}`});return Object.assign({},e,{actions:e?et(e.actions).map(t=>w(t)):[],cond:e&&e.cond?this.toGuard(e.cond):void 0,target:n,internal:s,event:i})}formatTransitions(){const t=this.config.on||A,e=this.config.onDone?{[`${V(this.id)}`]:this.config.onDone}:void 0,i=this.invoke.reduce((t,e)=>(e.onDone&&(t[_(e.id)]=e.onDone),e.onError&&(t[y]=e.onError),t),{}),s=this.after,n=Q(Object.assign({},t,e,i),(t,e)=>void 0===t?[{target:void 0,event:e,actions:[],internal:!0}]:ct(t)?t.map(t=>this.formatTransition(t.target,t,e)):lt(t)||t instanceof G?[this.formatTransition([t],void 0,e)]:[this.formatTransition(t.target,t,e)]);for(const t of s)n[t.event]=n[t.event]||[],n[t.event].push(t);return n}}function U(t){return!lt(t)&&("value"in t&&"tree"in t&&"history"in t)}function q(t){return Object.keys(t)}function B(t,e,s=i){const n=J(t,s),o=J(e,s);return lt(o)?!!lt(n)&&o===n:lt(n)?n in o:q(n).every(t=>t in o&&B(n[t],o[t]))}function X(t){try{return lt(t)||"number"==typeof t?`${t}`:t.type}catch(t){throw new Error("Events must be strings or objects with a string event.type property.")}}function H(t,e){try{return ct(t)?t:t.toString().split(e)}catch(e){throw new Error(`'${t}' is not a valid state path.`)}}function J(t,e){if(U(t))return t.value;if(ct(t))return K(t);if("string"!=typeof t&&!U(t))return t;return K(H(t,e))}function K(t){if(1===t.length)return t[0];const e={};let i=e;for(let e=0;e<t.length-1;e++)e===t.length-2?i[t[e]]=t[e+1]:(i[t[e]]={},i=i[t[e]]);return e}function Q(t,e){const i={},s=q(t);for(let n=0;n<s.length;n++){const o=s[n];i[o]=e(t[o],o,t,n)}return i}function W(t,e,i){const s={};for(const n of q(t)){const o=t[n];i(o)&&(s[n]=e(o,n,t))}return s}const Y=t=>e=>{let i=e;for(const e of t)i=i[e];return i};const Z=t=>{if(!t)return[[]];if(lt(t))return[[t]];return tt(q(t).map(e=>{const i=t[e];return"string"==typeof i||Object.keys(i).length?Z(t[e]).map(t=>[e].concat(t)):[[e]]}))};function tt(t){return[].concat(...t)}function et(t){return ct(t)?t:void 0===t?[]:[t]}function it(t,e,i){if(dt(t))return t(e,i);const s={};for(const n of q(t)){const o=t[n];dt(o)?s[n]=o(e,i):s[n]=o}return s}function st(t){return t instanceof Promise||!(null===t||!dt(t)&&"object"!=typeof t||!dt(t.then))}function nt(t,e){const[i,s]=[[],[]];for(const n of t)e(n)?i.push(n):s.push(n);return[i,s]}function ot(t,e){return Q(t.states,(t,i)=>{if(!t)return;const s=(lt(e)?void 0:e[i])||(t?t.current:void 0);return s?{current:s,states:ot(t,s)}:void 0})}function rt(e,i,s){return e?s.reduce((e,s)=>{const{assignment:n}=s;let o={};if(dt(n))o=n(e,i||{type:t.Init});else for(const t of q(n)){const s=n[t];o[t]=dt(s)?s(e,i):s}return Object.assign({},e,o)},e):e}function at(t,e){const{exec:i}=t;return Object.assign({},t,{exec:void 0!==i?()=>i(e.context,e.event,{action:t,state:e}):void 0})}let ht=()=>{};function ct(t){return Array.isArray(t)}function dt(t){return"function"==typeof t}function lt(t){return"string"==typeof t}function ut(t,e){let i;for(const s of q(t))B(s,e)&&(!i||e.length>i.length)&&(i=s);return t[i]}function ft(t,e,i=t.context){return new G(t,e,i)}const pt={deferEvents:!1};class vt{constructor(t){this.processingEvent=!1,this.queue=[],this.initialized=!1,this.options=Object.assign({},pt,t)}initialize(t){if(this.initialized=!0,t){if(!this.options.deferEvents)return void this.schedule(t);this.process(t)}this.flushEvents()}schedule(t){if(this.initialized&&!this.processingEvent){if(0!==this.queue.length)throw new Error("Event queue should be empty when it is not processing events");this.process(t),this.flushEvents()}else this.queue.push(t)}flushEvents(){let t=this.queue.shift();for(;t;)this.process(t),t=this.queue.shift()}process(t){this.processingEvent=!0;try{t()}catch(t){throw this.queue=[],t}finally{this.processingEvent=!1}}}class yt{constructor(t,i=yt.defaultOptions){this.machine=t,this.scheduler=new vt,this.delayedEventsMap={},this.listeners=new Set,this.contextListeners=new Set,this.stopListeners=new Set,this.doneListeners=new Set,this.eventListeners=new Set,this.sendListeners=new Set,this.initialized=!1,this.children=new Map,this.forwardTo=new Set,this.init=this.start,this.send=((t,e)=>{if(ct(t))return this.batch(t),this.state;const i=m(t,e);if(!this.initialized&&this.options.deferEvents)ht(!1,`Event "${i.type}" was sent to uninitialized service "${this.machine.id}" and is deferred. Make sure .start() is called for this service.\nEvent: ${JSON.stringify(t)}`);else if(!this.initialized)throw new Error(`Event "${i.type}" was sent to uninitialized service "${this.machine.id}". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: ${JSON.stringify(i)}`);return this.scheduler.schedule(()=>{const t=this.nextState(i);this.update(t,i),this.forward(i)}),this.state}),this.sender=(t=>{return function(){return this.send(t)}.bind(this)}),this.sendTo=((t,i)=>{const s=i===e.Parent,n=s?this.parent:this.children.get(i);if(n)n.send(t);else{if(!s)throw new Error(`Unable to send event to child '${i}' from service '${this.id}'.`);ht(!1,`Service '${this.id}' has no parent: unable to send event ${t.type}`)}});const s=Object.assign({},yt.defaultOptions,i),{clock:n,logger:o,parent:r,id:a}=s,h=void 0!==a?a:t.id;Object.assign(this,{clock:n,logger:o,parent:r,id:h}),this.options=s,this.scheduler=new vt({deferEvents:this.options.deferEvents})}get initialState(){return this.machine.initialState}execute(t){for(const e of t.actions)this.exec(e,t.context,t.event)}update(t,e){if(this.state=t,this.options.execute&&this.execute(this.state),this.devTools&&this.devTools.send(e,t),t.event)for(const e of this.eventListeners)e(t.event);for(const e of this.listeners)e(t,t.event);for(const t of this.contextListeners)t(this.state.context,this.state.history?this.state.history.context:void 0);if(this.state.tree&&this.state.tree.done){const t=this.state.tree.getDoneData(this.state.context,m(e));for(const e of this.doneListeners)e(_(this.id,t));this.stop()}}onTransition(t){return this.listeners.add(t),this}onEvent(t){return this.eventListeners.add(t),this}onSend(t){return this.sendListeners.add(t),this}onChange(t){return this.contextListeners.add(t),this}onStop(t){return this.stopListeners.add(t),this}onDone(t){return this.doneListeners.add(t),this}off(t){return this.listeners.delete(t),this.eventListeners.delete(t),this.sendListeners.delete(t),this.stopListeners.delete(t),this.doneListeners.delete(t),this.contextListeners.delete(t),this}start(t){const e=void 0===t?this.machine.initialState:t instanceof o?this.machine.resolveState(t):this.machine.resolveState(o.from(t));return this.initialized=!0,this.options.devTools&&this.attachDev(),this.scheduler.initialize(()=>{this.update(e,{type:p})}),this}stop(){for(const t of this.listeners)this.listeners.delete(t);for(const t of this.stopListeners)t(),this.stopListeners.delete(t);for(const t of this.contextListeners)this.contextListeners.delete(t);for(const t of this.doneListeners)this.doneListeners.delete(t);this.children.forEach(t=>{dt(t.stop)&&t.stop()});for(const t of q(this.delayedEventsMap))this.clock.clearTimeout(this.delayedEventsMap[t]);return this.initialized=!1,this}batch(t){if(!this.initialized&&this.options.deferEvents)ht(!1,`${t.length} event(s) were sent to uninitialized service "${this.machine.id}" and are deferred. Make sure .start() is called for this service.\nEvent: ${JSON.stringify(event)}`);else if(!this.initialized)throw new Error(`${t.length} event(s) were sent to uninitialized service "${this.machine.id}". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.`);this.scheduler.schedule(()=>{let e=this.state;for(const i of t){const t=m(i),s=e.actions.map(t=>at(t,e));(e=this.machine.transition(e,t)).actions.unshift(...s),this.forward(t)}this.update(e,m(t[t.length-1]))})}nextState(t){const e=m(t);if(e.type===y&&-1===this.state.nextEvents.indexOf(y))throw e.data;return this.machine.transition(this.state,e,this.state.context)}forward(t){for(const e of this.forwardTo){const i=this.children.get(e);if(!i)throw new Error(`Unable to forward event '${t}' from interpreter '${this.id}' to nonexistant child '${e}'.`);i.send(t)}}defer(t){let{delay:e}=t;if(lt(e)){if(!this.machine.options.delays||void 0===this.machine.options.delays[e])return void ht(!1,`No delay reference for delay expression '${e}' was found on machine '${this.machine.id}' on service '${this.id}'.`);{const t=this.machine.options.delays[e];e="number"==typeof t?t:t(this.state.context,this.state.event)}}this.delayedEventsMap[t.id]=this.clock.setTimeout(()=>{t.to?this.sendTo(t.event,t.to):this.send(t.event)},e||0)}cancel(t){this.clock.clearTimeout(this.delayedEventsMap[t]),delete this.delayedEventsMap[t]}exec(e,i,s){if(e.exec)return e.exec(i,s,{action:e,state:this.state});switch(e.type){case c:const n=e;if(n.delay)return void this.defer(n);n.to?this.sendTo(n.event,n.to):this.send(n.event);break;case d:this.cancel(e.sendId);break;case r:{const n=e.activity;if(!this.state.activities[n.type])break;if(n.type===t.Invoke){const t=this.machine.options.services?this.machine.options.services[n.src]:void 0,{id:e,data:o}=n,r=!!n.forward;if(!t)return void ht(!1,`No service found for invocation '${n.src}' in machine '${this.machine.id}'.`);const a=dt(t)?t(i,s):t;st(a)?this.spawnPromise(e,Promise.resolve(a)):dt(a)?this.spawnCallback(e,a):"string"!=typeof a&&this.spawn(o?a.withContext(it(o,i,s)):a,{id:e,autoForward:r})}else this.spawnActivity(n);break}case a:this.stopChild(e.activity.id);break;case f:const o=e.expr?e.expr(i,s):void 0;e.label?this.logger(e.label,o):this.logger(o);break;default:ht(!1,`No implementation found for action type '${e.type}'`)}}stopChild(t){const e=this.children.get(t);e&&dt(e.stop)&&(e.stop(),this.children.delete(t),this.forwardTo.delete(t))}spawn(t,e={}){const i=new yt(t,{parent:this,id:e.id||t.id});return i.onDone(t=>{this.send(t)}).start(),this.children.set(i.id,i),e.autoForward&&this.forwardTo.add(i.id),i}spawnPromise(t,e){let i=!1;e.then(e=>{i||this.send(_(t,e))}).catch(e=>{if(!i){const i=I(e,t);try{this.send(i)}catch(t){this.devTools&&this.devTools.send(i,this.state),this.machine.strict&&this.stop()}}}),this.children.set(t,{send:()=>void 0,stop:()=>{i=!0}})}spawnCallback(t,e){const i=t=>this.send(t);let s,n=e=>{ht(!1,`Event '${e.type}' sent to callback service '${t}' but was not handled by a listener.`)};try{st(s=e(i,t=>{n=t}))&&Promise.resolve(s).catch(e=>{const i=I(e,t);try{this.send(i)}catch(t){this.devTools&&this.devTools.send(i,this.state),this.machine.strict&&this.stop()}})}catch(e){this.send(I(e,t))}this.children.set(t,{send:n,stop:s})}spawnActivity(t){const e=this.machine.options&&this.machine.options.activities?this.machine.options.activities[t.type]:void 0;if(!e)return void ht(!1,`No implementation found for activity '${t.type}'`);const i=e(this.state.context,t);this.spawnEffect(t.id,i)}spawnEffect(t,e){this.children.set(t,{send:()=>void 0,stop:e})}reportUnhandledExceptionOnInvocation(t,e,i){const s=t.stack?` Stacktrace was '${t.stack}'`:"";if(t===e)console.error(`Missing onError handler for invocation '${i}', error was '${t}'.${s}`);else{const n=e.stack?` Stacktrace was '${e.stack}'`:"";console.error(`Missing onError handler and/or unhandled exception/promise rejection for invocation '${i}'. `+`Original error: '${t}'. ${s} Current error is '${e}'.${n}`)}}attachDev(){this.options.devTools&&"undefined"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__&&(this.devTools=window.__REDUX_DEVTOOLS_EXTENSION__.connect({name:this.id,features:{jump:!1,skip:!1}}),this.devTools.init(this.state))}}function gt(t,e){return new yt(t,e)}function mt(t,e,i){const s=o.from(t,t instanceof o?t.context:void 0);for(const[t,i]of e)if(s.matches(t))return i(s);return i(s)}yt.defaultOptions=(t=>({execute:!0,deferEvents:!0,clock:{setTimeout:(e,i)=>t.setTimeout.call(null,e,i),clearTimeout:e=>t.clearTimeout.call(null,e)},logger:t.console.log.bind(console),devTools:!1}))("undefined"==typeof window?global:window),yt.interpret=gt;const St={raise:E,send:N,sendParent:b,log:function(t=((t,e)=>({context:t,event:e})),e){return{type:f,label:e,expr:t}},cancel:$,start:O,stop:k,assign:T,after:j,done:V};export{ft as Machine,G as StateNode,o as State,B as matchesState,ut as mapState,St as actions,T as assign,N as send,b as sendParent,gt as interpret,yt as Interpreter,mt as matchState,t as ActionTypes,e as SpecialTargets};
