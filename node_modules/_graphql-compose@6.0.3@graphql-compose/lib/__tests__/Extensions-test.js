"use strict";

var _ = require("..");

var _EnumTypeComposer = require("../EnumTypeComposer");

var _InputTypeComposer = require("../InputTypeComposer");

var _InterfaceTypeComposer = require("../InterfaceTypeComposer");

var _ScalarTypeComposer = require("../ScalarTypeComposer");

var _ObjectTypeComposer = require("../ObjectTypeComposer");

var _UnionTypeComposer = require("../UnionTypeComposer");

beforeEach(() => {
  _.schemaComposer.clear();
});
describe('Extensions', () => {
  describe('ObjectTypeComposer', () => {
    it('has type Extensions methods', () => {
      const tc = _ObjectTypeComposer.ObjectTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        }
      }, _.schemaComposer);

      testTypeExtensions(tc);
    });
    it('has field Extensions methods', () => {
      const tc = _ObjectTypeComposer.ObjectTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        }
      }, _.schemaComposer);

      testFieldExtensions(tc);
    });
    it('has type extension initializers', () => {
      const tc = _ObjectTypeComposer.ObjectTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        },
        extensions: {
          tags: ['generated']
        }
      }, _.schemaComposer);

      expect(tc.getExtensions()).toEqual({
        tags: ['generated']
      });
    });
    it('has field extension initializers', () => {
      const tc = _ObjectTypeComposer.ObjectTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: {
            type: 'String',
            extensions: {
              noFilter: true
            }
          }
        }
      }, _.schemaComposer);

      expect(tc.getFieldExtensions('name')).toEqual({
        noFilter: true
      });
    });
  });
  describe('InputTypeComposer', () => {
    it('has type Extensions methods', () => {
      const tc = _InputTypeComposer.InputTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        }
      }, _.schemaComposer);

      testTypeExtensions(tc);
    });
    it('has field Extensions methods', () => {
      const tc = _InputTypeComposer.InputTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        }
      }, _.schemaComposer);

      testFieldExtensions(tc);
    });
    it('has type extension initializers', () => {
      const tc = _InputTypeComposer.InputTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        },
        extensions: {
          tags: ['generated']
        }
      }, _.schemaComposer);

      expect(tc.getExtensions()).toEqual({
        tags: ['generated']
      });
    });
    it('has field extension initializers', () => {
      const tc = _InputTypeComposer.InputTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: {
            type: 'String',
            extensions: {
              noFilter: true
            }
          }
        }
      }, _.schemaComposer);

      expect(tc.getFieldExtensions('name')).toEqual({
        noFilter: true
      });
    });
  });
  describe('InterfaceTypeComposer', () => {
    it('has type Extensions methods', () => {
      const tc = _InterfaceTypeComposer.InterfaceTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        }
      }, _.schemaComposer);

      testTypeExtensions(tc);
    });
    it('has field Extensions methods', () => {
      const tc = _InterfaceTypeComposer.InterfaceTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        }
      }, _.schemaComposer);

      testFieldExtensions(tc);
    });
    it('has type extension initializers', () => {
      const tc = _InterfaceTypeComposer.InterfaceTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        },
        extensions: {
          tags: ['generated']
        }
      }, _.schemaComposer);

      expect(tc.getExtensions()).toEqual({
        tags: ['generated']
      });
    });
    it('has field extension initializers', () => {
      const tc = _InterfaceTypeComposer.InterfaceTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: {
            type: 'String',
            extensions: {
              noFilter: true
            }
          }
        }
      }, _.schemaComposer);

      expect(tc.getFieldExtensions('name')).toEqual({
        noFilter: true
      });
    });
  });
  describe('EnumTypeComposer', () => {
    it('has type Extensions methods', () => {
      const tc = _EnumTypeComposer.EnumTypeComposer.create({
        name: 'Foo',
        values: {
          FOO: {
            value: 'FOO'
          },
          BAR: {
            value: 'BAR'
          }
        }
      }, _.schemaComposer);

      testTypeExtensions(tc);
    });
    it('has type extension initializers', () => {
      const tc = _EnumTypeComposer.EnumTypeComposer.create({
        name: 'Foo',
        values: {
          FOO: {
            value: 'FOO'
          },
          BAR: {
            value: 'BAR'
          }
        },
        extensions: {
          tags: ['generated']
        }
      }, _.schemaComposer);

      expect(tc.getExtensions()).toEqual({
        tags: ['generated']
      });
    });
  });
  describe('UnionTypeComposer', () => {
    it('has type Extensions methods', () => {
      const foo = _ObjectTypeComposer.ObjectTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        }
      }, _.schemaComposer);

      const tc = _UnionTypeComposer.UnionTypeComposer.create({
        name: 'FooUnion',
        types: [foo]
      }, _.schemaComposer);

      testTypeExtensions(tc);
    });
    it('has type extension initializers', () => {
      const foo = _ObjectTypeComposer.ObjectTypeComposer.create({
        name: 'Foo',
        fields: {
          id: 'ID!',
          name: 'String'
        }
      }, _.schemaComposer);

      const tc = _UnionTypeComposer.UnionTypeComposer.create({
        name: 'FooUnion',
        types: [foo],
        extensions: {
          tags: ['generated']
        }
      }, _.schemaComposer);

      expect(tc.getExtensions()).toEqual({
        tags: ['generated']
      });
    });
  });
  describe('ScalarTypeComposer', () => {
    it('has type Extensions methods', () => {
      const tc = _ScalarTypeComposer.ScalarTypeComposer.create({
        name: 'Foo',

        serialize() {}

      }, _.schemaComposer);

      testTypeExtensions(tc);
    });
    it('has type extension initializers', () => {
      const tc = _ScalarTypeComposer.ScalarTypeComposer.create({
        name: 'Foo',
        serialize: () => {},
        extensions: {
          tags: ['generated']
        }
      }, _.schemaComposer);

      expect(tc.getExtensions()).toEqual({
        tags: ['generated']
      });
    });
  });

  function testTypeExtensions(instance) {
    expect(instance.getExtensions()).toEqual({});
    instance.setExtensions({
      tags: ['generated'],
      source: 'inference'
    });
    expect(instance.getExtensions()).toEqual({
      tags: ['generated'],
      source: 'inference'
    });
    instance.extendExtensions({
      source: 'user',
      originalName: 'foo'
    });
    expect(instance.getExtensions()).toEqual({
      tags: ['generated'],
      source: 'user',
      originalName: 'foo'
    });
    expect(instance.getExtension('source')).toEqual('user');
    expect(instance.hasExtension('source')).toEqual(true);
    expect(instance.hasExtension('nonExistant')).toEqual(false);
    instance.setExtension('source', 'inference');
    expect(instance.getExtensions()).toEqual({
      tags: ['generated'],
      source: 'inference',
      originalName: 'foo'
    });
    expect(instance.getExtension('source')).toEqual('inference');
    instance.removeExtension('originalName');
    expect(instance.getExtensions()).toEqual({
      tags: ['generated'],
      source: 'inference'
    });
    instance.clearExtensions();
    expect(instance.getExtensions()).toEqual({});
    expect(instance.hasExtension('source')).toEqual(false);
    instance.setExtensions({
      tags: ['generated'],
      source: 'inference'
    });
    expect(instance.getExtensions()).toEqual({
      tags: ['generated'],
      source: 'inference'
    });
    instance.clearExtensions();
  }

  function testFieldExtensions(instance) {
    expect(instance.getFieldExtensions('id')).toEqual({});
    instance.setFieldExtensions('id', {
      tags: ['generated'],
      source: 'inference'
    });
    expect(instance.getFieldExtensions('id')).toEqual({
      tags: ['generated'],
      source: 'inference'
    });
    instance.extendFieldExtensions('id', {
      source: 'user',
      originalName: 'foo'
    });
    expect(instance.getFieldExtensions('id')).toEqual({
      tags: ['generated'],
      source: 'user',
      originalName: 'foo'
    });
    expect(instance.getFieldExtension('id', 'source')).toEqual('user');
    expect(instance.hasFieldExtension('id', 'source')).toEqual(true);
    expect(instance.hasFieldExtension('id', 'nonExistant')).toEqual(false);
    instance.setFieldExtension('id', 'source', 'inference');
    expect(instance.getFieldExtensions('id')).toEqual({
      tags: ['generated'],
      source: 'inference',
      originalName: 'foo'
    });
    expect(instance.getFieldExtension('id', 'source')).toEqual('inference');
    instance.removeFieldExtension('id', 'originalName');
    expect(instance.getFieldExtensions('id')).toEqual({
      tags: ['generated'],
      source: 'inference'
    });
    instance.clearFieldExtensions('id');
    expect(instance.getFieldExtensions('id')).toEqual({});
    expect(instance.hasFieldExtension('id', 'source')).toEqual(false);
    instance.setFieldExtensions('id', {
      tags: ['generated'],
      source: 'inference'
    });
    expect(instance.getFieldExtensions('id')).toEqual({
      tags: ['generated'],
      source: 'inference'
    });
    instance.clearFieldExtensions('id');
  }
});