{"componentChunkName":"component---src-templates-blog-post-js","path":"/arts-08/","result":{"data":{"site":{"siteMetadata":{"title":"Funny Eagle","author":"Jason Yang"}},"markdownRemark":{"id":"ec2a744c-e0cb-5536-945b-c8552ea7032e","excerpt":"Algorithm Review https://docs.docker.com/network/host/\nhttp://cizixs.com/2016/06/12/docker-network-…","html":"<h2 id=\"algorithm\" style=\"position:relative;\"><a href=\"#algorithm\" aria-label=\"algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithm</h2>\n<pre><code class=\"language-java\">package org.nocoder.leetcode.solution;\n\n/**\n * https://leetcode.com/problems/string-to-integer-atoi/description/\n * &#x3C;p>\n * 8. String to Integer (atoi)\n * &#x3C;p>\n * Implement atoi which converts a string to an integer.\n * &#x3C;p>\n * The function first discards as many whitespace characters as necessary until the first non-whitespace character is found.\n * Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as\n * possible, and interprets them as a numerical value.\n * &#x3C;p>\n * The string can contain additional characters after those that form the integral number, which are ignored and have no\n * effect on the behavior of this function.\n * &#x3C;p>\n * If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists\n * because either str is empty or it contains only whitespace characters, no conversion is performed.\n * &#x3C;p>\n * If no valid conversion could be performed, a zero value is returned.\n * &#x3C;p>\n * Note:\n * &#x3C;p>\n * Only the space character ' ' is considered as whitespace character.\n * Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:\n * [−2 31,  2 31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2 31 − 1) or\n * INT_MIN (−2 31) is returned.\n * Example 1:\n * &#x3C;p>\n * Input: \"42\"\n * Output: 42\n * Example 2:\n * &#x3C;p>\n * Input: \"   -42\"\n * Output: -42\n * Explanation: The first non-whitespace character is '-', which is the minus sign.\n * Then take as many numerical digits as possible, which gets 42.\n * Example 3:\n * &#x3C;p>\n * Input: \"4193 with words\"\n * Output: 4193\n * Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.\n * Example 4:\n * &#x3C;p>\n * Input: \"words and 987\"\n * Output: 0\n * Explanation: The first non-whitespace character is 'w', which is not a numerical\n * digit or a +/- sign. Therefore no valid conversion could be performed.\n * Example 5:\n * &#x3C;p>\n * Input: \"-91283472332\"\n * Output: -2147483648\n * Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer.\n * Thefore INT_MIN (−231) is returned.\n *\n * @author jason\n * @date 18/8/26.\n */\npublic class StringToInteger {\n\n    public static int myAtoi(String str) {\n        if (str == null || \"\".equals(str = str.trim())) {\n            return 0;\n        }\n\n        // 字母开头\n        if (str.matches(\"^[a-zA-Z]\\\\w{0,31}$\")) {\n            return 0;\n        }\n\n        int i = 0;\n        char flag = '+';\n        // 判断正负\n        if (str.charAt(i) == '-'){\n            flag = '-';\n            i++;\n        } else if (str.charAt(i) == '+') {\n            flag = '+';\n            i++;\n        }\n\n        double result = 0;\n        //计算对应的整数\n        while (i &#x3C; str.length() &#x26;&#x26; str.charAt(i) >= '0' &#x26;&#x26; str.charAt(i) &#x3C;= '9') {\n            result = result * 10 + (str.charAt(i) - '0');\n            i++;\n        }\n\n        if (flag == '-') {\n            result = -result;\n        }\n\n        // 越界处理\n        if (result > Integer.MAX_VALUE) {\n            return Integer.MAX_VALUE;\n        } else if (result &#x3C; Integer.MIN_VALUE) {\n            return Integer.MIN_VALUE;\n        }\n\n        return (int) result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(myAtoi(\"123abc\"));\n        System.out.println(myAtoi(\"  \"));\n        System.out.println(myAtoi(null));\n        System.out.println(myAtoi(\"hello123\"));\n        System.out.println(myAtoi(\"9999999999999999999999999\"));\n        System.out.println(myAtoi(\"-9999999999999999999999999\"));\n        System.out.println(myAtoi(\"1000\"));\n        System.out.println(myAtoi(\"0001\"));\n        System.out.println(myAtoi(\"-888\"));\n        System.out.println(myAtoi(\"   9999    2222\"));\n    }\n}\n\n</code></pre>\n<h2 id=\"review\" style=\"position:relative;\"><a href=\"#review\" aria-label=\"review permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Review</h2>\n<blockquote>\n<p><a href=\"https://docs.docker.com/network/host/\">https://docs.docker.com/network/host/</a>\n<a href=\"http://cizixs.com/2016/06/12/docker-network-modes-explained\">http://cizixs.com/2016/06/12/docker-network-modes-explained</a></p>\n</blockquote>\n<h2 id=\"tip\" style=\"position:relative;\"><a href=\"#tip\" aria-label=\"tip permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tip</h2>\n<p>docker container 使用主机网络</p>\n<p>背景</p>\n<blockquote>\n<p>多个docker容器分布在不同的宿主机上，并且都要通过 eureka 进行服务调用，跨主机调用时，如果使用的是docker 容器内部网络，那么在调用不同宿主机上的服务时，就会出现找不到服务的现象，通过使用主机网络，解决了这个问题</p>\n</blockquote>\n<p>在docker run 后追加长命令 <code>--net=host</code> 即可使docker container 使用宿主机网络</p>\n<h2 id=\"share\" style=\"position:relative;\"><a href=\"#share\" aria-label=\"share permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Share</h2>\n<h3 id=\"observer-pattern\" style=\"position:relative;\"><a href=\"#observer-pattern\" aria-label=\"observer pattern permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Observer Pattern</h3>\n<blockquote>\n<p>观察者模式也称为发布订阅模式，当一个对象的状态发生变化时，通知其他对象，其他对象根据变化做相应的操作。例如，<code>book</code>表的数量内容发生变化后，相应的数据统计表要根据book数量进行增量统计，这时候<code>book</code>表对应的对象就是被观察者，而相关的统计表对应的实体对象就是观察者。</p>\n</blockquote>\n<p>被观察者(发布者)</p>\n<pre><code class=\"language-java\">package org.nocoder.observer;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 被观察者（发布者）\n */\npublic class Subject {\n\n    /**\n     * 观察者\n     */\n    private List&#x3C;Observer> observers = new ArrayList&#x3C;Observer>();\n\n    private int state;\n\n    public int getState() {\n        return state;\n    }\n\n    public void setState(int state) {\n        this.state = state;\n        // 状态变更通知已订阅的观察者\n        notifyAllObservers();\n    }\n\n    /**\n     * 添加订阅\n     * @param observer\n     */\n    public void addObserver(Observer observer){\n        observers.add(observer);\n    }\n\n    /**\n     * 通知已订阅的观察者\n     */\n    public void notifyAllObservers(){\n        for (Observer observer : observers) {\n            observer.update();\n        }\n    }\n}\n\n</code></pre>\n<p>观察者抽象类</p>\n<pre><code class=\"language-java\">package org.nocoder.observer;\n\n/**\n * 观察者抽象类\n */\npublic abstract class Observer {\n\n    protected Subject subject;\n\n    public abstract void update();\n}\n\n</code></pre>\n<p>BinaryObserver</p>\n<pre><code class=\"language-java\">package org.nocoder.observer;\n\npublic class BinaryObserver extends Observer {\n\n    public BinaryObserver(Subject subject){\n        this.subject = subject;\n        this.subject.addObserver(this);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(this.getClass().getName() + \": \" + Integer.toBinaryString(subject.getState()));\n    }\n}\n</code></pre>\n<p>HexaObserver</p>\n<pre><code class=\"language-java\">package org.nocoder.observer;\n\npublic class HexaObserver extends Observer {\n\n    public HexaObserver(Subject subject){\n        this.subject = subject;\n        this.subject.addObserver(this);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(this.getClass().getName() + \": \" + Integer.toHexString(subject.getState()));\n    }\n}\n</code></pre>\n<p>OctalObserver</p>\n<pre><code class=\"language-java\">package org.nocoder.observer;\n\npublic class OctalObserver extends Observer {\n\n    public OctalObserver(Subject subject){\n        this.subject = subject;\n        this.subject.addObserver(this);\n    }\n\n    @Override\n    public void update() {\n        System.out.println(this.getClass().getName() + \": \" + Integer.toOctalString(subject.getState()));\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">package org.nocoder.observer;\n\npublic class Demo {\n    public static void main(String[] args) {\n        // 被观察者\n        Subject subject = new Subject();\n\n        // 观察者\n        new BinaryObserver(subject);\n        new OctalObserver(subject);\n        new HexaObserver(subject);\n\n        // 触发事件通知已经订阅的观察者\n        subject.setState(15);\n\n        // 触发事件通知已经订阅的观察者\n        subject.setState(100);\n\n        // 观察者消费订阅，执行 update() 方法\n    }\n}\n</code></pre>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#algorithm\">Algorithm</a></p>\n</li>\n<li>\n<p><a href=\"#review\">Review</a></p>\n</li>\n<li>\n<p><a href=\"#tip\">Tip</a></p>\n</li>\n<li>\n<p><a href=\"#share\">Share</a></p>\n<ul>\n<li><a href=\"#observer-pattern\">Observer Pattern</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"ARTS 第8周","tags":["coding","arts"],"description":"Algorithm, Reiview, Tip and Share","date":"2018-08-26"}}},"pageContext":{"slug":"/arts-08/","previous":{"fields":{"slug":"/arts-07/"},"frontmatter":{"title":"ARTS 第7周","tags":["coding","arts"],"slug":""}},"next":{"fields":{"slug":"/arts-09/"},"frontmatter":{"title":"ARTS 第9周","tags":["coding","arts"],"slug":""}}}},"staticQueryHashes":["2052298874"],"slicesMap":{}}