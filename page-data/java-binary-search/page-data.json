{"componentChunkName":"component---src-templates-blog-post-js","path":"/java-binary-search/","result":{"data":{"site":{"siteMetadata":{"title":"Jason Yang's Website","author":"Jason Yang"}},"markdownRemark":{"id":"1d5d6143-426e-57b2-bd72-70eb9e4d2de8","excerpt":"二分查找法是一种常见的对数值列表的查找方法。使用二分查找法的前提条件是数组中的元素必须已经排好序。二分查找法首先将关键字与数组的中间元素进行比较。考虑一下三种情况： 如果关键字小于中间元素，只需要在…","html":"<blockquote>\n<p>二分查找法是一种常见的对数值列表的查找方法。使用二分查找法的前提条件是数组中的元素必须已经排好序。二分查找法首先将关键字与数组的中间元素进行比较。考虑一下三种情况：</p>\n</blockquote>\n<ul>\n<li>如果关键字小于中间元素，只需要在数组的前一半元素中继续查找关键字。</li>\n<li>如果关键字和中间元素相等，则匹配成功，查找结束。</li>\n<li>如果关键字大于中间元素，只需要在数组的后一半元素中继续查找关键字。</li>\n</ul>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">package org.nocoder.solution;\r\n\r\n/**\r\n * @author jason\r\n * @date 18/4/19.\r\n */\r\npublic class BinarySearch {\r\n    public static int binarySearch(int [] list, int key){\r\n        int low = 0;\r\n        int high = list.length - 1;\r\n\r\n        while(high &gt;= low){\r\n            int mid = (low + high) / 2;\r\n            if(key &lt; list[mid]){\r\n                high = mid - 1;\r\n            }else if(key == list[mid]){\r\n                return mid;\r\n            }else{\r\n                low = mid + 1;\r\n            }\r\n        }\r\n\t    // 如果关键字不在该序列中，返回-low-1，\r\n\t\t// 表明不在序列中，并且返回关键字应该插入的位置\r\n        return -low-1;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.print(binarySearch(new int []{1,2,3,4,5}, 5));\r\n    }\r\n}\r\n</code>\n        </deckgo-highlight-code>\n<p>再附上一道【剑指offer】的编程练习题及题解</p>\n<blockquote>\n<p>题目描述：二维数组中的查找</p>\n</blockquote>\n<p>对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。\r\n给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，返回-1。\r\n若该元素出现多次，请返回第一次出现的位置。</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">package org.nocoder.solution;\r\n\r\n/**\r\n * 题目描述\r\n * 对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。\r\n * 给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，返回-1。\r\n * 若该元素出现多次，请返回第一次出现的位置。\r\n * 测试样例：\r\n * [1,3,5,7,9],5,3\r\n * [4,4,10,21],4,4\r\n * 返回：1\r\n *\r\n * @author jason\r\n * @date 18/4/1.\r\n */\r\npublic class BinarySearch {\r\n    public int getPos(int[] A, int n, int val) {\r\n        // low:起始位置下标\r\n        int low = 0;\r\n        // high:结束位置下标\r\n        int high = n - 1;\r\n\r\n        while (high &gt; low) {\r\n            // mid:中间位置下标\r\n            int mid = (low + high) / 2;\r\n            if (val &lt; A[mid]) {\r\n                // 如果目标值在左侧，结束位置下标修改为mid-1\r\n                high = mid - 1;\r\n            } else if (val == A[mid]) {\r\n                // 如果目标值等于中间位置下标对应的值，将结束位置下标设置为中间位置下标，继续向左查找\r\n                high = mid;\r\n            } else {\r\n                // 如果目标值在右侧，起始查找的位置下标修改为mid+1\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        return A[low] == val ? low : -1;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        int[] array = {10, 10, 10, 10, 10, 10, 10, 10};\r\n        BinarySearch bs = new BinarySearch();\r\n        System.out.println(bs.getPos(array, 8, 10));\r\n    }\r\n}\r\n</code>\n        </deckgo-highlight-code>","tableOfContents":"","frontmatter":{"title":"Java 二分查找法","tags":["coding"],"description":"Java实现二分查找法。","date":"2018-04-18"}}},"pageContext":{"slug":"/java-binary-search/","previous":{"fields":{"slug":"/java-interview-questions/"},"frontmatter":{"title":"几道Java相关的面试题","tags":["coding"],"slug":""}},"next":{"fields":{"slug":"/sleepless-in-java/"},"frontmatter":{"title":"读《Java夜未眠》部分笔记","tags":["coding"],"slug":""}}}},"staticQueryHashes":["2052298874"],"slicesMap":{}}