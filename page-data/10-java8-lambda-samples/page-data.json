{"componentChunkName":"component---src-templates-blog-post-js","path":"/10-java8-lambda-samples/","result":{"data":{"site":{"siteMetadata":{"title":"Funny Eagle","author":"Jason Yang"}},"markdownRemark":{"id":"1714aa3c-8c64-5427-ac37-078ec92575f5","excerpt":"本文由 ImportNew - lemeilleur 翻译自 javarevisited。欢迎加入翻译小组。转载请见文末要求。 Java 8 刚于几周前发布，日期是2014年3月18日，这次开创性的…","html":"<blockquote>\n<p>本文由 ImportNew - lemeilleur 翻译自 javarevisited。欢迎加入翻译小组。转载请见文末要求。</p>\n</blockquote>\n<p>Java 8 刚于几周前发布，日期是2014年3月18日，这次开创性的发布在Java社区引发了不少讨论，并让大家感到激动。特性之一便是随同发布的lambda表达式，它将允许我们将行为传到函数里。在Java 8之前，如果想将行为传入函数，仅有的选择就是匿名类，需要6行代码。而定义行为最重要的那行代码，却混在中间不够突出。Lambda表达式取代了匿名类，取消了模板，允许用函数式风格编写代码。这样有时可读性更好，表达更清晰。在Java生态系统中，函数式表达与对面向对象的全面支持是个激动人心的进步。将进一步促进并行第三方库的发展，充分利用多核CPU。尽管业界需要时间来消化Java 8，但我认为任何严谨的Java开发者都不应忽视此次Java发布的核心特性，即lambda表达式、函数式接口、流API、默认方法和新的Date以及Time API。作为开发人员，我发现学习和掌握lambda表达式的最佳方法就是勇于尝试，尽可能多练习lambda表达式例子。鉴于受Java 8发布的影响最大的是Java集合框架（Java Collections framework），所以最好练习流API和lambda表达式，用于对列表（Lists）和集合（Collections）数据进行提取、过滤和排序。我一直在进行关于Java 8的写作，过去也曾分享过一些资源来帮助大家掌握Java 8。本文分享在代码中最有用的10个lambda表达式的使用方法，这些例子都短小精悍，将帮助你快速学会lambda表达式。</p>\n<h2 id=\"java-8-lambda表达式示例\" style=\"position:relative;\"><a href=\"#java-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B\" aria-label=\"java 8 lambda表达式示例 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java 8 lambda表达式示例</h2>\n<p>我个人对Java 8发布非常激动，尤其是lambda表达式和流API。越来越多的了解它们，我能写出更干净的代码。虽然一开始并不是这样。第一次看到用lambda表达式写出来的Java代码时，我对这种神秘的语法感到非常失望，认为它们把Java搞得不可读，但我错了。花了一天时间做了一些lambda表达式和流API示例的练习后，我开心的看到了更清晰的Java代码。这有点像学习泛型，第一次见的时候我很讨厌它。我甚至继续使用老版Java 1.4来处理集合，直到有一天，朋友跟我介绍了使用泛型的好处（才意识到它的好处）。所以基本立场就是，不要畏惧lambda表达式以及方法引用的神秘语法，做几次练习，从集合类中提取、过滤数据之后，你就会喜欢上它。下面让我们开启学习Java 8 lambda表达式的学习之旅吧，首先从简单例子开始。</p>\n<h3 id=\"例1用lambda表达式实现runnable\" style=\"position:relative;\"><a href=\"#%E4%BE%8B1%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0runnable\" aria-label=\"例1用lambda表达式实现runnable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例1、用lambda表达式实现Runnable</h3>\n<p>我开始使用Java 8时，首先做的就是使用lambda表达式替换匿名类，而实现Runnable接口是匿名类的最好示例。看一下Java 8之前的runnable实现方法，需要4行代码，而使用lambda表达式只需要一行代码。我们在这里做了什么呢？那就是用() -> {}代码块替代了整个匿名类。</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Java 8之前：</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Before Java8, too much code for too little to do\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//Java 8方式：</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"In Java8, Lambda expression rocks !!\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p> 输出</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">too much code, for too little to do\nLambda expression rocks !!</code></pre></div>\n<p>这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> expression\n<span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> statement\n<span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span> statements <span class=\"token punctuation\">}</span></code></pre></div>\n<p>例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello Lambda Expressions\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果你的方法接收两个参数，那么可以写成如下这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(int even, int odd) -> even + odd</code></pre></div>\n<p>顺便提一句，通常都会把lambda表达式内部变量的名字起得短一些。这样能使代码更简短，放在同一行。所以，在上述代码中，变量名选用a、b或者x、y会比even、odd要好。</p>\n<h3 id=\"例2使用java-8-lambda表达式进行事件处理\" style=\"position:relative;\"><a href=\"#%E4%BE%8B2%E4%BD%BF%E7%94%A8java-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86\" aria-label=\"例2使用java 8 lambda表达式进行事件处理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例2、使用Java 8 lambda表达式进行事件处理</h3>\n<p>如果你用过Swing API编程，你就会记得怎样写事件监听代码。这又是一个旧版本简单匿名类的经典用例，但现在可以不这样了。你可以用lambda表达式写出更好的事件监听代码，如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Java 8之前：\nJButton show =  new JButton(\"Show\");\nshow.addActionListener(new ActionListener() {\n    @Override\n    public void actionPerformed(ActionEvent e) {\n    System.out.println(\"Event handling without lambda expression is boring\");\n    }\n});</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Java 8方式：\nshow.addActionListener((e) -> {\n    System.out.println(\"Light, Camera, Action !! Lambda expressions Rocks\");\n});</code></pre></div>\n<p>Java开发者经常使用匿名类的另一个地方是为 Collections.sort() 定制 Comparator。在Java 8中，你可以用更可读的lambda表达式换掉丑陋的匿名类。我把这个留做练习，应该不难，可以按照我在使用lambda表达式实现 Runnable 和 ActionListener 的过程中的套路来做。</p>\n<h3 id=\"例3使用lambda表达式对列表进行迭代\" style=\"position:relative;\"><a href=\"#%E4%BE%8B3%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9%E5%88%97%E8%A1%A8%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3\" aria-label=\"例3使用lambda表达式对列表进行迭代 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例3、使用lambda表达式对列表进行迭代</h3>\n<p>如果你使过几年Java，你就知道针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java 8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果你想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。下面的例子里，我将介绍如何在使用lambda或不使用lambda表达式的情况下迭代列表。你可以看到列表现在有了一个 forEach()  方法，它可以迭代所有对象，并将你的lambda代码应用在其中。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Java 8之前：\nList features = Arrays.asList(\"Lambdas\", \"Default Method\", \"Stream API\", \"Date and Time API\");\nfor (String feature : features) {\n    System.out.println(feature);\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Java 8之后：\nList features = Arrays.asList(\"Lambdas\", \"Default Method\", \"Stream API\", \"Date and Time API\");\nfeatures.forEach(n -> System.out.println(n));\n \n// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，\n// 看起来像C++的作用域解析运算符\nfeatures.forEach(System.out::println);</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Lambdas\nDefault Method\nStream API\nDate and Time API</code></pre></div>\n<p>列表循环的最后一个例子展示了如何在Java 8中使用方法引用（method reference）。你可以看到C++里面的双冒号、范围解析操作符现在在Java 8中用来表示方法引用。</p>\n<p>###例4、使用lambda表达式和函数式接口Predicate\n除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。下面是Java 8 Predicate 的例子，展示了过滤集合数据的多种常用方法。Predicate接口非常适用于做过滤。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public static void main(args[]){\n    List languages = Arrays.asList(\"Java\", \"Scala\", \"C++\", \"Haskell\", \"Lisp\");\n \n    System.out.println(\"Languages which starts with J :\");\n    filter(languages, (str)->str.startsWith(\"J\"));\n \n    System.out.println(\"Languages which ends with a \");\n    filter(languages, (str)->str.endsWith(\"a\"));\n \n    System.out.println(\"Print all languages :\");\n    filter(languages, (str)->true);\n \n    System.out.println(\"Print no language : \");\n    filter(languages, (str)->false);\n \n    System.out.println(\"Print language whose length greater than 4:\");\n    filter(languages, (str)->str.length() > 4);\n}\n \npublic static void filter(List names, Predicate condition) {\n    for(String name: names)  {\n        if(condition.test(name)) {\n            System.out.println(name + \" \");\n        }\n    }\n}</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Languages which starts with J :\nJava\nLanguages which ends with a\nJava\nScala\nPrint all languages :\nJava\nScala\nC++\nHaskell\nLisp\nPrint no language :\nPrint language whose length greater than 4:\nScala\nHaskell</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 更好的办法\npublic static void filter(List names, Predicate condition) {\n    names.stream().filter((name) -> (condition.test(name))).forEach((name) -> {\n        System.out.println(name + \" \");\n    });\n}</code></pre></div>\n<p>可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这就是lambda表达式的魔力。另外，Predicate接口也允许进行多重条件的测试，下个例子将要讲到。</p>\n<h3 id=\"例5如何在lambda表达式中加入predicate\" style=\"position:relative;\"><a href=\"#%E4%BE%8B5%E5%A6%82%E4%BD%95%E5%9C%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E5%8A%A0%E5%85%A5predicate\" aria-label=\"例5如何在lambda表达式中加入predicate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例5、如何在lambda表达式中加入Predicate</h3>\n<p>上个例子说到，java.util.function.Predicate 允许将两个或更多的 Predicate 合成一个。它提供类似于逻辑操作符AND和OR的方法，名字叫做and()、or()和xor()，用于将传入 filter() 方法的条件合并起来。例如，要得到所有以J开始，长度为四个字母的语言，可以定义两个独立的 Predicate 示例分别表示每一个条件，然后用 Predicate.and() 方法将它们合并起来，如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 甚至可以用and()、or()和xor()逻辑函数来合并Predicate，\n// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入\nPredicate&lt;String> startsWithJ = (n) -> n.startsWith(\"J\");\nPredicate&lt;String> fourLetterLong = (n) -> n.length() == 4;\nnames.stream()\n    .filter(startsWithJ.and(fourLetterLong))\n    .forEach((n) -> System.out.print(\"nName, which starts with 'J' and four letter long is : \" + n));</code></pre></div>\n<p>类似地，也可以使用 or() 和 xor() 方法。本例着重介绍了如下要点：可按需要将 Predicate 作为单独条件然后将其合并起来使用。简而言之，你可以以传统Java命令方式使用 Predicate 接口，也可以充分利用lambda表达式达到事半功倍的效果。</p>\n<h3 id=\"例6java-8中使用lambda表达式的map和reduce示例\" style=\"position:relative;\"><a href=\"#%E4%BE%8B6java-8%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84map%E5%92%8Creduce%E7%A4%BA%E4%BE%8B\" aria-label=\"例6java 8中使用lambda表达式的map和reduce示例 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例6、Java 8中使用lambda表达式的Map和Reduce示例</h3>\n<p>本例介绍最广为人知的函数式编程概念map。它允许你将对象进行转换。例如在本例中，我们将 costBeforeTax 列表的每个元素转换成为税后的值。我们将 x -> x*x lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。使用流API的收集器类，可以得到所有含税的开销。有 toList() 这样的方法将 map 或任何其他操作的结果合并起来。由于收集器在流上做终端操作，因此之后便不能重用流了。你甚至可以用流API的 reduce() 方法将所有数字合成一个，下一个例子将会讲到。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 不使用lambda表达式为每个订单加上12%的税\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\nfor (Integer cost : costBeforeTax) {\n    double price = cost + .12*cost;\n    System.out.println(price);\n}\n \n// 使用lambda表达式\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ncostBeforeTax.stream().map((cost) -> cost + .12*cost).forEach(System.out::println);</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">112.0\n224.0\n336.0\n448.0\n560.0\n112.0\n224.0\n336.0\n448.0\n560.0</code></pre></div>\n<h3 id=\"例62java-8中使用lambda表达式的map和reduce示例\" style=\"position:relative;\"><a href=\"#%E4%BE%8B62java-8%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84map%E5%92%8Creduce%E7%A4%BA%E4%BE%8B\" aria-label=\"例62java 8中使用lambda表达式的map和reduce示例 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例6.2、Java 8中使用lambda表达式的Map和Reduce示例</h3>\n<p>在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。在这个Java 8的Map Reduce示例里，我们首先对所有价格应用 12% 的VAT，然后用 reduce() 方法计算总和。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 为每个订单加上12%的税\n// 老方法：\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ndouble total = 0;\nfor (Integer cost : costBeforeTax) {\n    double price = cost + .12*cost;\n    total = total + price;\n}\nSystem.out.println(\"Total : \" + total);\n \n// 新方法：\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ndouble bill = costBeforeTax.stream().map((cost) -> cost + .12*cost).reduce((sum, cost) -> sum + cost).get();\nSystem.out.println(\"Total : \" + bill);</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Total : 1680.0\nTotal : 1680.0</code></pre></div>\n<h3 id=\"例7通过过滤创建一个string列表\" style=\"position:relative;\"><a href=\"#%E4%BE%8B7%E9%80%9A%E8%BF%87%E8%BF%87%E6%BB%A4%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAstring%E5%88%97%E8%A1%A8\" aria-label=\"例7通过过滤创建一个string列表 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例7、通过过滤创建一个String列表</h3>\n<p>过滤是Java开发者在大规模集合上的一个常用操作，而现在使用lambda表达式和流API过滤大规模数据集合是惊人的简单。流提供了一个 filter() 方法，接受一个 Predicate 对象，即可以传入一个lambda表达式作为过滤逻辑。下面的例子是用lambda表达式过滤Java集合，将帮助理解。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 创建一个字符串列表，每个字符串长度大于2\nList&lt;String> filtered = strList.stream().filter(x -> x.length()> 2).collect(Collectors.toList());\nSystem.out.printf(\"Original List : %s, filtered list : %s %n\", strList, filtered);</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Original List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]</code></pre></div>\n<p>另外，关于 filter() 方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。</p>\n<h3 id=\"例8对列表的每个元素应用函数\" style=\"position:relative;\"><a href=\"#%E4%BE%8B8%E5%AF%B9%E5%88%97%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0\" aria-label=\"例8对列表的每个元素应用函数 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例8、对列表的每个元素应用函数</h3>\n<p>我们通常需要对列表的每个元素使用某个函数，例如逐一乘以某个数、除以某个数或者做其它操作。这些操作都很适合用 map() 方法，可以将转换逻辑以lambda表达式的形式放在 map() 方法里，就可以对集合的各个元素进行转换了，如下所示。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 将字符串换成大写并用逗号链接起来\nList&lt;String> G7 = Arrays.asList(\"USA\", \"Japan\", \"France\", \"Germany\", \"Italy\", \"U.K.\",\"Canada\");\nString G7Countries = G7.stream().map(x -> x.toUpperCase()).collect(Collectors.joining(\", \"));\nSystem.out.println(G7Countries);</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">USA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA</code></pre></div>\n<h3 id=\"例9复制不同的值创建一个子列表\" style=\"position:relative;\"><a href=\"#%E4%BE%8B9%E5%A4%8D%E5%88%B6%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E5%88%97%E8%A1%A8\" aria-label=\"例9复制不同的值创建一个子列表 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例9、复制不同的值，创建一个子列表</h3>\n<p>本例展示了如何利用流的 distinct() 方法来对集合进行去重。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 用所有不同的数字创建一个正方形列表\nList&lt;Integer> numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);\nList&lt;Integer> distinct = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());\nSystem.out.printf(\"Original List : %s,  Square Without duplicates : %s %n\", numbers, distinct);</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Original List : [9, 10, 3, 4, 7, 3, 4],  Square Without duplicates : [81, 100, 9, 16, 49]</code></pre></div>\n<h3 id=\"例10计算集合元素的最大值最小值总和以及平均值\" style=\"position:relative;\"><a href=\"#%E4%BE%8B10%E8%AE%A1%E7%AE%97%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC%E6%80%BB%E5%92%8C%E4%BB%A5%E5%8F%8A%E5%B9%B3%E5%9D%87%E5%80%BC\" aria-label=\"例10计算集合元素的最大值最小值总和以及平均值 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例10、计算集合元素的最大值、最小值、总和以及平均值</h3>\n<p>IntStream、LongStream 和 DoubleStream 等流的类中，有个非常有用的方法叫做 summaryStatistics() 。可以返回 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistic s，描述流中元素的各种摘要数据。在本例中，我们用这个方法来计算列表的最大值和最小值。它也有 getSum() 和 getAverage() 方法来获得列表的所有元素的总和及平均值。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//获取数字的个数、最小值、最大值、总和以及平均值\nList&lt;Integer> primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\nIntSummaryStatistics stats = primes.stream().mapToInt((x) -> x).summaryStatistics();\nSystem.out.println(\"Highest prime number in List : \" + stats.getMax());\nSystem.out.println(\"Lowest prime number in List : \" + stats.getMin());\nSystem.out.println(\"Sum of all prime numbers : \" + stats.getSum());\nSystem.out.println(\"Average of all prime numbers : \" + stats.getAverage());</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Highest prime number in List : 29\nLowest prime number in List : 2\nSum of all prime numbers : 129\nAverage of all prime numbers : 12.9</code></pre></div>\n<p>Lambda表达式 vs 匿名类</p>\n<p>既然lambda表达式即将正式取代Java代码中的匿名内部类，那么有必要对二者做一个比较分析。一个关键的不同点就是关键字 this。匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。另一个不同点是二者的编译方式。Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 invokedynamic 字节码指令来动态绑定这个方法。</p>\n<p>Java 8 Lambda表达式要点</p>\n<p>10个Java lambda表达式、流API示例\n到目前为止我们看到了Java 8的10个lambda表达式，这对于新手来说是个合适的任务量，你可能需要亲自运行示例程序以便掌握。试着修改要求创建自己的例子，达到快速学习的目的。我还想建议大家使用Netbeans IDE来练习lambda表达式，它对Java 8支持良好。当把代码转换成函数式的时候，Netbeans会及时给你提示。只需跟着Netbeans的提示，就能很容易地把匿名类转换成lambda表达式。此外，如果你喜欢阅读，那么记得看一下Java 8的lambdas，实用函数式编程这本书（Java 8 Lambdas, pragmatic functional programming），作者是Richard Warburton，或者也可以看看Manning的Java 8实战（Java 8 in Action），这本书虽然还没出版，但我猜线上有第一章的免费pdf。不过，在你开始忙其它事情之前，先回顾一下Java 8的lambda表达式、默认方法和函数式接口的重点知识。</p>\n<p>1）lambda表达式仅能放入如下代码：预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM（Single Abstract Method 单个抽象方法）类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。</p>\n<p>2）lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">list.forEach(n -> System.out.println(n)); \nlist.forEach(System.out::println);  // 使用方法引用</code></pre></div>\n<p>然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">list.forEach((String s) -> System.out.println(\"*\" + s + \"*\"));</code></pre></div>\n<p>事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。</p>\n<p>3）lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。</p>\n<p>4）Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。</p>\n<p>5）Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">private static java.lang.Object lambda$0(java.lang.String);</code></pre></div>\n<p>6）lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">List&lt;Integer> primes = Arrays.asList(new Integer[]{2, 3,5,7});\nint factor = 2;\nprimes.forEach(element -> { factor++; });</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Compile time error : \"local variables referenced from a lambda expression must be final or effectively final\"</code></pre></div>\n<p>另外，只是访问它而不作修改是可以的，如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">List&lt;Integer> primes = Arrays.asList(new Integer[]{2, 3,5,7});\nint factor = 2;\nprimes.forEach(element -> { System.out.println(factor*element); });</code></pre></div>\n<p>输出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1\n2\n3\n4\n4\n6\n10\n14</code></pre></div>\n<p>因此，它看起来更像不可变闭包，类似于Python。</p>\n<p>以上就是Java 8的lambda表达式的全部10个例子。此次修改将成为Java史上最大的一次，将深远影响未来Java开发者使用集合框架的方式。我想规模最相似的一次修改就是Java 5的发布了，它带来了很多优点，提升了代码质量，例如：泛型、枚举、自动装箱（Autoboxing）、静态导入、并发API和变量参数。上述特性使得Java代码更加清晰，我想lambda表达式也将进一步改进它。我在期待着开发并行第三方库，这可以使高性能应用变得更容易写。</p>\n<blockquote>\n<p>更多阅读：<a href=\"http://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#ixzz3gCMp6Vhc\">http://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#ixzz3gCMp6Vhc</a></p>\n</blockquote>\n<p>原文链接： javarevisited 翻译： ImportNew.com - lemeilleur\n译文链接： <a href=\"http://www.importnew.com/16436.html\">http://www.importnew.com/16436.html</a>\n[ 转载请保留原文出处、译者和译文链接。]\n作者： lemeilleur</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#java-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B\">Java 8 lambda表达式示例</a></p>\n<ul>\n<li><a href=\"#%E4%BE%8B1%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0runnable\">例1、用lambda表达式实现Runnable</a></li>\n<li><a href=\"#%E4%BE%8B2%E4%BD%BF%E7%94%A8java-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86\">例2、使用Java 8 lambda表达式进行事件处理</a></li>\n<li><a href=\"#%E4%BE%8B3%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9%E5%88%97%E8%A1%A8%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3\">例3、使用lambda表达式对列表进行迭代</a></li>\n<li><a href=\"#%E4%BE%8B5%E5%A6%82%E4%BD%95%E5%9C%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E5%8A%A0%E5%85%A5predicate\">例5、如何在lambda表达式中加入Predicate</a></li>\n<li><a href=\"#%E4%BE%8B6java-8%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84map%E5%92%8Creduce%E7%A4%BA%E4%BE%8B\">例6、Java 8中使用lambda表达式的Map和Reduce示例</a></li>\n<li><a href=\"#%E4%BE%8B62java-8%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84map%E5%92%8Creduce%E7%A4%BA%E4%BE%8B\">例6.2、Java 8中使用lambda表达式的Map和Reduce示例</a></li>\n<li><a href=\"#%E4%BE%8B7%E9%80%9A%E8%BF%87%E8%BF%87%E6%BB%A4%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAstring%E5%88%97%E8%A1%A8\">例7、通过过滤创建一个String列表</a></li>\n<li><a href=\"#%E4%BE%8B8%E5%AF%B9%E5%88%97%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0\">例8、对列表的每个元素应用函数</a></li>\n<li><a href=\"#%E4%BE%8B9%E5%A4%8D%E5%88%B6%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E5%88%97%E8%A1%A8\">例9、复制不同的值，创建一个子列表</a></li>\n<li><a href=\"#%E4%BE%8B10%E8%AE%A1%E7%AE%97%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC%E6%80%BB%E5%92%8C%E4%BB%A5%E5%8F%8A%E5%B9%B3%E5%9D%87%E5%80%BC\">例10、计算集合元素的最大值、最小值、总和以及平均值</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"【转载】Java8 lambda表达式10个示例","tags":["coding"],"description":"本文由 ImportNew - lemeilleur 翻译自 javarevisited。","date":"2017-06-10"}}},"pageContext":{"slug":"/10-java8-lambda-samples","previous":{"fields":{"slug":"/regular-expression"},"frontmatter":{"title":"正则表达式","tags":["coding"],"slug":"/regular-expression"}},"next":{"fields":{"slug":"/enum-instead-const"},"frontmatter":{"title":"使用枚举替换常量类","tags":["coding"],"slug":"/enum-instead-const"}}}},"staticQueryHashes":["2052298874"],"slicesMap":{}}