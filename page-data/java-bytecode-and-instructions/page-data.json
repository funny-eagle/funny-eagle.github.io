{"componentChunkName":"component---src-templates-blog-post-js","path":"/java-bytecode-and-instructions/","result":{"data":{"site":{"siteMetadata":{"title":"Funny Eagle","author":"Jason Yang"}},"markdownRemark":{"id":"11a57277-b815-5b88-9f49-a1715c405eef","excerpt":"Java 字节码是Java虚拟机执行的一种指令格式。大多数操作码都是一个字节长，而有些操作需要参数，导致了有一些多字节的操作码。而且并不是所有可能的256个操作码都被使用；其中有51个操作码被保留做…","html":"<blockquote>\n<p>Java 字节码是Java虚拟机执行的一种指令格式。大多数操作码都是一个字节长，而有些操作需要参数，导致了有一些多字节的操作码。而且并不是所有可能的256个操作码都被使用；其中有51个操作码被保留做将来使用。除此之外，Sun 公司额外保留了3个代码永久不使用。</p>\n</blockquote>\n<h2 id=\"指令\" style=\"position:relative;\"><a href=\"#%E6%8C%87%E4%BB%A4\" aria-label=\"指令 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>指令</h2>\n<p>每一个字节，有256个可能的代码值（2^8=256），因此一个字节的操作码最多可能有256种不同的操作。其中，0x00、0xFE、0xCA、0xFF被指定保留。例如0xCA作为一个Java调试器的中断指令而从未被语言使用。相似地，0xFE和0xFF也未被语言使用。</p>\n<p>指令可以基本分为以下几类：</p>\n<ul>\n<li>存储指令 （例如：aload_0, istore）</li>\n<li>算术与逻辑指令 （例如: ladd, fcmpl）</li>\n<li>类型转换指令 （例如：i2b, d2i）</li>\n<li>对象创建与操作指令 （例如：new, putfield）</li>\n<li>堆栈操作指令 （例如：swap, dup2）</li>\n<li>控制转移指令 （例如：ifeq, goto）</li>\n<li>方法调用与返回指令 （例如：invokespecial, areturn)</li>\n</ul>\n<p>除此之外，还有一些更特殊的指令，作为异常抛出或同步等作用。</p>\n<p>大多数的指令有前缀和（或）后缀来表明其操作数的类型。如下表</p>\n<table>\n<thead>\n<tr>\n<th>前/后缀</th>\n<th>操作数类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>i</td>\n<td>整数</td>\n</tr>\n<tr>\n<td>l</td>\n<td>长整数</td>\n</tr>\n<tr>\n<td>s</td>\n<td>短整数</td>\n</tr>\n<tr>\n<td>b</td>\n<td>字节</td>\n</tr>\n<tr>\n<td>c</td>\n<td>字符</td>\n</tr>\n<tr>\n<td>f</td>\n<td>单精度浮点数</td>\n</tr>\n<tr>\n<td>d</td>\n<td>双精度浮点数</td>\n</tr>\n<tr>\n<td>z</td>\n<td>布尔值</td>\n</tr>\n<tr>\n<td>a</td>\n<td>引用</td>\n</tr>\n</tbody>\n</table>\n<p>例如，“iadd”指令将两个整数相加；而”dadd”指令将两个double浮点数相加。\r\n此外，“const”、 “load”、 “store”等命令还会使用”_n”后缀，其中 “load”和”store”命令中的n可以为0到3之间的整数；而”const”命令中的n由类型指定。 const”指令把一个指定类型的值放入堆栈。例如”iconst_5”指令将一个整数5放入堆栈；而”dconst_1”将一个双精度浮点数1放入堆栈。\r\n此外还有”aconst_null”指令，放入一个null进堆栈。而对于”load” “store”指令中的n，指定了变量表中的存储位置。“aload_0”指令把在变量0中的对象（通常是”this”对象）放入堆栈，“istore_1”指令把栈顶的一个整数放入变量1.对于更高的变量，后缀将被去除，而这条指令将需要操作数。</p>\n<h2 id=\"指令集\" style=\"position:relative;\"><a href=\"#%E6%8C%87%E4%BB%A4%E9%9B%86\" aria-label=\"指令集 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>指令集</h2>\n<table>\n<thead>\n<tr>\n<th>助记词</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nop</td>\n<td>None</td>\n</tr>\n<tr>\n<td>aconst_null</td>\n<td>将null推送至栈顶</td>\n</tr>\n<tr>\n<td>iconst_m1</td>\n<td>将int型-1推送至栈顶</td>\n</tr>\n<tr>\n<td>iconst_0</td>\n<td>将int型0推送至栈顶</td>\n</tr>\n<tr>\n<td>iconst_1</td>\n<td>将int型1推送至栈顶</td>\n</tr>\n<tr>\n<td>iconst_2</td>\n<td>将int型2推送至栈顶</td>\n</tr>\n<tr>\n<td>iconst_3</td>\n<td>将int型3推送至栈顶</td>\n</tr>\n<tr>\n<td>iconst_4</td>\n<td>将int型4推送至栈顶</td>\n</tr>\n<tr>\n<td>iconst_5</td>\n<td>将int型5推送至栈顶</td>\n</tr>\n<tr>\n<td>lconst_0</td>\n<td>将long型0推送至栈顶</td>\n</tr>\n<tr>\n<td>lconst_1</td>\n<td>将long型1推送至栈顶</td>\n</tr>\n<tr>\n<td>fconst_0</td>\n<td>将float型0推送至栈顶</td>\n</tr>\n<tr>\n<td>fconst_1</td>\n<td>将float型1推送至栈顶</td>\n</tr>\n<tr>\n<td>fconst_2</td>\n<td>将float型2推送至栈顶</td>\n</tr>\n<tr>\n<td>dconst_0</td>\n<td>将double型0推送至栈顶</td>\n</tr>\n<tr>\n<td>dconst_1</td>\n<td>将double型1推送至栈顶</td>\n</tr>\n<tr>\n<td>bipush</td>\n<td>将单字节的常量值(-128~127)推送至栈顶</td>\n</tr>\n<tr>\n<td>sipush</td>\n<td>将一个短整型常量(-32768~32767)推送至栈顶</td>\n</tr>\n<tr>\n<td>ldc</td>\n<td>将int,float或String型常量值从常量池中推送至栈顶</td>\n</tr>\n<tr>\n<td>ldc_w</td>\n<td>将int,float或String型常量值从常量池中推送至栈顶(宽索引)</td>\n</tr>\n<tr>\n<td>ldc2_w</td>\n<td>将long或double型常量值从常量池中推送至栈顶(宽索引)</td>\n</tr>\n<tr>\n<td>iload</td>\n<td>将指定的int型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>lload</td>\n<td>将指定的long型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>fload</td>\n<td>将指定的float型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>dload</td>\n<td>将指定的double型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>aload</td>\n<td>将指定的引用类型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>iload_0</td>\n<td>将第一个int型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>iload_1</td>\n<td>将第二个int型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>iload_2</td>\n<td>将第三个int型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>iload_3</td>\n<td>将第四个int型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>lload_0</td>\n<td>将第一个long型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>lload_1</td>\n<td>将第二个long型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>lload_2</td>\n<td>将第三个long型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>lload_3</td>\n<td>将第四个long型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>fload_0</td>\n<td>将第一个float型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>fload_1</td>\n<td>将第二个float型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>fload_2</td>\n<td>将第三个float型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>fload_3</td>\n<td>将第四个float型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>dload_0</td>\n<td>将第一个double型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>dload_1</td>\n<td>将第二个double型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>dload_2</td>\n<td>将第三个double型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>dload_3</td>\n<td>将第四个double型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>aload_0</td>\n<td>将第一个引用类型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>aload_1</td>\n<td>将第二个引用类型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>aload_2</td>\n<td>将第三个引用类型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>aload_3</td>\n<td>将第四个引用类型本地变量推送至栈顶</td>\n</tr>\n<tr>\n<td>iaload</td>\n<td>将int型数组指定索引的值推送至栈顶</td>\n</tr>\n<tr>\n<td>laload</td>\n<td>将long型数组指定索引的值推送至栈顶</td>\n</tr>\n<tr>\n<td>faload</td>\n<td>将float型数组指定索引的值推送至栈顶</td>\n</tr>\n<tr>\n<td>daload</td>\n<td>将double型数组指定索引的值推送至栈顶</td>\n</tr>\n<tr>\n<td>aaload</td>\n<td>将引用类型数组指定索引的值推送至栈顶</td>\n</tr>\n<tr>\n<td>baload</td>\n<td>将boolean或byte型数组指定索引的值推送至栈顶</td>\n</tr>\n<tr>\n<td>caload</td>\n<td>将char型数组指定索引的值推送至栈顶</td>\n</tr>\n<tr>\n<td>saload</td>\n<td>将short型数组指定索引的值推送至栈顶</td>\n</tr>\n<tr>\n<td>istore</td>\n<td>将栈顶int型数值存入指定本地变量</td>\n</tr>\n<tr>\n<td>lstore</td>\n<td>将栈顶long型数值存入指定本地变量</td>\n</tr>\n<tr>\n<td>fstore</td>\n<td>将栈顶float型数值存入指定本地变量</td>\n</tr>\n<tr>\n<td>dstore</td>\n<td>将栈顶double型数值存入指定本地变量</td>\n</tr>\n<tr>\n<td>astore</td>\n<td>将栈顶引用类型数值存入指定本地变量</td>\n</tr>\n<tr>\n<td>istore_0</td>\n<td>将栈顶int型数值存入第一个本地变量</td>\n</tr>\n<tr>\n<td>istore_1</td>\n<td>将栈顶int型数值存入第二个本地变量</td>\n</tr>\n<tr>\n<td>istore_2</td>\n<td>将栈顶int型数值存入第三个本地变量</td>\n</tr>\n<tr>\n<td>istore_3</td>\n<td>将栈顶int型数值存入第四个本地变量</td>\n</tr>\n<tr>\n<td>lstore_0</td>\n<td>将栈顶long型数值存入第一个本地变量</td>\n</tr>\n<tr>\n<td>lstore_1</td>\n<td>将栈顶long型数值存入第二个本地变量</td>\n</tr>\n<tr>\n<td>lstore_2</td>\n<td>将栈顶long型数值存入第三个本地变量</td>\n</tr>\n<tr>\n<td>lstore_3</td>\n<td>将栈顶long型数值存入第四个本地变量</td>\n</tr>\n<tr>\n<td>fstore_0</td>\n<td>将栈顶float型数值存入第一个本地变量</td>\n</tr>\n<tr>\n<td>fstore_1</td>\n<td>将栈顶float型数值存入第二个本地变量</td>\n</tr>\n<tr>\n<td>fstore_2</td>\n<td>将栈顶float型数值存入第三个本地变量</td>\n</tr>\n<tr>\n<td>fstore_3</td>\n<td>将栈顶float型数值存入第四个本地变量</td>\n</tr>\n<tr>\n<td>dstore_0</td>\n<td>将栈顶double型数值存入第一个本地变量</td>\n</tr>\n<tr>\n<td>dstore_1</td>\n<td>将栈顶double型数值存入第二个本地变量</td>\n</tr>\n<tr>\n<td>dstore_2</td>\n<td>将栈顶double型数值存入第三个本地变量</td>\n</tr>\n<tr>\n<td>dstore_3</td>\n<td>将栈顶double型数值存入第四个本地变量</td>\n</tr>\n<tr>\n<td>astore_0</td>\n<td>将栈顶引用型数值存入第一个本地变量</td>\n</tr>\n<tr>\n<td>astore_1</td>\n<td>将栈顶引用型数值存入第二个本地变量</td>\n</tr>\n<tr>\n<td>astore_2</td>\n<td>将栈顶引用型数值存入第三个本地变量</td>\n</tr>\n<tr>\n<td>astore_3</td>\n<td>将栈顶引用型数值存入第四个本地变量</td>\n</tr>\n<tr>\n<td>iastore</td>\n<td>将栈顶int型数值存入指定数组的指定索引位置</td>\n</tr>\n<tr>\n<td>lastore</td>\n<td>将栈顶long型数值存入指定数组的指定索引位置</td>\n</tr>\n<tr>\n<td>fastore</td>\n<td>将栈顶float型数值存入指定数组的指定索引位置</td>\n</tr>\n<tr>\n<td>dastore</td>\n<td>将栈顶double型数值存入指定数组的指定索引位置</td>\n</tr>\n<tr>\n<td>aastore</td>\n<td>将栈顶引用型数值存入指定数组的指定索引位置</td>\n</tr>\n<tr>\n<td>bastore</td>\n<td>将栈顶boolean或byte型数值存入指定数组的指定索引位置</td>\n</tr>\n<tr>\n<td>castore</td>\n<td>将栈顶char型数值存入指定数组的指定索引位置</td>\n</tr>\n<tr>\n<td>sastore</td>\n<td>将栈顶short型数值存入指定数组的指定索引位置</td>\n</tr>\n<tr>\n<td>pop</td>\n<td>将栈顶数值弹出(数值不能是long或double类型的)</td>\n</tr>\n<tr>\n<td>pop2</td>\n<td>将栈顶的一个(对于非long或double类型)或两个数值(对于非long或double的其他类型)弹出</td>\n</tr>\n<tr>\n<td>dup</td>\n<td>复制栈顶数值并将复制值压入栈顶</td>\n</tr>\n<tr>\n<td>dup_x1\t复制栈顶数值并将两个复制值压入栈顶</td>\n<td></td>\n</tr>\n<tr>\n<td>dup_x2\t复制栈顶数值并将三个(或两个)复制值压入栈顶</td>\n<td></td>\n</tr>\n<tr>\n<td>dup2</td>\n<td>复制栈顶一个(对于long或double类型)或两个(对于非long或double的其他类型)数值并将复制值压入栈顶</td>\n</tr>\n<tr>\n<td>dup2_x1</td>\n<td>dup_x1指令的双倍版本</td>\n</tr>\n<tr>\n<td>dup2_x2</td>\n<td>dup_x2指令的双倍版本</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>将栈顶最顶端的两个数值互换(数值不能是long或double类型)</td>\n</tr>\n<tr>\n<td>iadd</td>\n<td>将栈顶两int型数值相加并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>ladd</td>\n<td>将栈顶两long型数值相加并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>fadd</td>\n<td>将栈顶两float型数值相加并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>dadd</td>\n<td>将栈顶两double型数值相加并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>isub</td>\n<td>将栈顶两int型数值相减并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lsub</td>\n<td>将栈顶两long型数值相减并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>fsub</td>\n<td>将栈顶两float型数值相减并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>dsub</td>\n<td>将栈顶两double型数值相减并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>imul</td>\n<td>将栈顶两int型数值相乘并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lmul</td>\n<td>将栈顶两long型数值相乘并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>fmul</td>\n<td>将栈顶两float型数值相乘并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>dmul</td>\n<td>将栈顶两double型数值相乘并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>idiv</td>\n<td>将栈顶两int型数值相除并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>ldiv</td>\n<td>将栈顶两long型数值相除并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>fdiv</td>\n<td>将栈顶两float型数值相除并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>ddiv</td>\n<td>将栈顶两double型数值相除并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>irem</td>\n<td>将栈顶两int型数值作取模运算并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lrem</td>\n<td>将栈顶两long型数值作取模运算并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>frem</td>\n<td>将栈顶两float型数值作取模运算并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>drem</td>\n<td>将栈顶两double型数值作取模运算并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>ineg</td>\n<td>将栈顶int型数值取负并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lneg</td>\n<td>将栈顶long型数值取负并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>fneg</td>\n<td>将栈顶float型数值取负并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>dneg</td>\n<td>将栈顶double型数值取负并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>ishl</td>\n<td>将int型数值左移指定位数并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lshl</td>\n<td>将long型数值左移指定位数并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>ishr</td>\n<td>将int型数值右(带符号)移指定位数并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lshr</td>\n<td>将long型数值右(带符号)移指定位数并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>iushr</td>\n<td>将int型数值右(无符号)移指定位数并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lushr</td>\n<td>将long型数值右(无符号)移指定位数并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>iand</td>\n<td>将栈顶两int型数值”按位与”并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>land</td>\n<td>将栈顶两long型数值”按位与”并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>ior</td>\n<td>将栈顶两int型数值”按位或”并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lor</td>\n<td>将栈顶两long型数值”按位或”并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>ixor</td>\n<td>将栈顶两int型数值”按位异或”并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lxor</td>\n<td>将栈顶两long型数值”按位异或”并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>iinc</td>\n<td>将指定int型变量增加指定值(如i++, i—, i+=2等)</td>\n</tr>\n<tr>\n<td>i2l</td>\n<td>将栈顶int型数值强制转换为long型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>i2f</td>\n<td>将栈顶int型数值强制转换为float型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>i2d</td>\n<td>将栈顶int型数值强制转换为double型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>l2i</td>\n<td>将栈顶long型数值强制转换为int型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>l2f</td>\n<td>将栈顶long型数值强制转换为float型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>l2d</td>\n<td>将栈顶long型数值强制转换为double型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>f2i</td>\n<td>将栈顶float型数值强制转换为int型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>f2l</td>\n<td>将栈顶float型数值强制转换为long型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>f2d</td>\n<td>将栈顶float型数值强制转换为double型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>d2i</td>\n<td>将栈顶double型数值强制转换为int型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>d2l</td>\n<td>将栈顶double型数值强制转换为long型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>d2f</td>\n<td>将栈顶double型数值强制转换为float型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>i2b</td>\n<td>将栈顶int型数值强制转换为byte型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>i2c</td>\n<td>将栈顶int型数值强制转换为char型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>i2s</td>\n<td>将栈顶int型数值强制转换为short型数值并将结果压入栈顶</td>\n</tr>\n<tr>\n<td>lcmp</td>\n<td>比较栈顶两long型数值大小, 并将结果(1, 0或-1)压入栈顶</td>\n</tr>\n<tr>\n<td>fcmpl</td>\n<td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶</td>\n</tr>\n<tr>\n<td>fcmpg</td>\n<td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶</td>\n</tr>\n<tr>\n<td>dcmpl</td>\n<td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶</td>\n</tr>\n<tr>\n<td>dcmpg</td>\n<td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶</td>\n</tr>\n<tr>\n<td>ifeq</td>\n<td>当栈顶int型数值等于0时跳转</td>\n</tr>\n<tr>\n<td>ifne</td>\n<td>当栈顶int型数值不等于0时跳转</td>\n</tr>\n<tr>\n<td>iflt</td>\n<td>当栈顶int型数值小于0时跳转</td>\n</tr>\n<tr>\n<td>ifge</td>\n<td>当栈顶int型数值大于等于0时跳转</td>\n</tr>\n<tr>\n<td>ifgt</td>\n<td>当栈顶int型数值大于0时跳转</td>\n</tr>\n<tr>\n<td>ifle</td>\n<td>当栈顶int型数值小于等于0时跳转</td>\n</tr>\n<tr>\n<td>if_icmpeq</td>\n<td>比较栈顶两int型数值大小, 当结果等于0时跳转</td>\n</tr>\n<tr>\n<td>if_icmpne</td>\n<td>比较栈顶两int型数值大小, 当结果不等于0时跳转</td>\n</tr>\n<tr>\n<td>if_icmplt</td>\n<td>比较栈顶两int型数值大小, 当结果小于0时跳转</td>\n</tr>\n<tr>\n<td>if_icmpge</td>\n<td>比较栈顶两int型数值大小, 当结果大于等于0时跳转</td>\n</tr>\n<tr>\n<td>if_icmpgt</td>\n<td>比较栈顶两int型数值大小, 当结果大于0时跳转</td>\n</tr>\n<tr>\n<td>if_icmple</td>\n<td>比较栈顶两int型数值大小, 当结果小于等于0时跳转</td>\n</tr>\n<tr>\n<td>if_acmpeq</td>\n<td>比较栈顶两引用型数值, 当结果相等时跳转</td>\n</tr>\n<tr>\n<td>if_acmpne</td>\n<td>比较栈顶两引用型数值, 当结果不相等时跳转</td>\n</tr>\n<tr>\n<td>goto</td>\n<td>无条件跳转</td>\n</tr>\n<tr>\n<td>jsr</td>\n<td>跳转至指定的16位offset位置, 并将jsr的下一条指令地址压入栈顶</td>\n</tr>\n<tr>\n<td>ret</td>\n<td>返回至本地变量指定的index的指令位置(一般与jsr或jsr_w联合使用)</td>\n</tr>\n<tr>\n<td>tableswitch</td>\n<td>用于switch条件跳转, case值连续(可变长度指令)</td>\n</tr>\n<tr>\n<td>lookupswitch</td>\n<td>用于switch条件跳转, case值不连续(可变长度指令)</td>\n</tr>\n<tr>\n<td>ireturn</td>\n<td>从当前方法返回int</td>\n</tr>\n<tr>\n<td>lreturn</td>\n<td>从当前方法返回long</td>\n</tr>\n<tr>\n<td>freturn</td>\n<td>从当前方法返回float</td>\n</tr>\n<tr>\n<td>dreturn</td>\n<td>从当前方法返回double</td>\n</tr>\n<tr>\n<td>areturn</td>\n<td>从当前方法返回对象引用</td>\n</tr>\n<tr>\n<td>return</td>\n<td>从当前方法返回void</td>\n</tr>\n<tr>\n<td>getstatic</td>\n<td>获取指定类的静态域, 并将其压入栈顶</td>\n</tr>\n<tr>\n<td>putstatic</td>\n<td>为指定类的静态域赋值</td>\n</tr>\n<tr>\n<td>getfield</td>\n<td>获取指定类的实例域, 并将其压入栈顶</td>\n</tr>\n<tr>\n<td>putfield</td>\n<td>为指定类的实例域赋值</td>\n</tr>\n<tr>\n<td>invokevirtual</td>\n<td>调用实例方法</td>\n</tr>\n<tr>\n<td>invokespecial</td>\n<td>调用超类构建方法, 实例初始化方法, 私有方法</td>\n</tr>\n<tr>\n<td>invokestatic</td>\n<td>调用静态方法</td>\n</tr>\n<tr>\n<td>invokeinterface</td>\n<td>调用接口方法</td>\n</tr>\n<tr>\n<td>invokedynamic</td>\n<td>调用动态方法</td>\n</tr>\n<tr>\n<td>new</td>\n<td>创建一个对象, 并将其引用引用值压入栈顶</td>\n</tr>\n<tr>\n<td>newarray</td>\n<td>创建一个指定的原始类型(如int, float, char等)的数组, 并将其引用值压入栈顶</td>\n</tr>\n<tr>\n<td>anewarray</td>\n<td>创建一个引用型(如类, 接口, 数组)的数组, 并将其引用值压入栈顶</td>\n</tr>\n<tr>\n<td>arraylength</td>\n<td>获取数组的长度值并压入栈顶</td>\n</tr>\n<tr>\n<td>athrow</td>\n<td>将栈顶的异常抛出</td>\n</tr>\n<tr>\n<td>checkcast</td>\n<td>检验类型转换, 检验未通过将抛出 ClassCastException</td>\n</tr>\n<tr>\n<td>instanceof</td>\n<td>检验对象是否是指定类的实际, 如果是将1压入栈顶, 否则将0压入栈顶</td>\n</tr>\n<tr>\n<td>monitorenter</td>\n<td>获得对象的锁, 用于同步方法或同步块</td>\n</tr>\n<tr>\n<td>monitorexit</td>\n<td>释放对象的锁, 用于同步方法或同步块</td>\n</tr>\n<tr>\n<td>wide</td>\n<td>扩展本地变量的宽度</td>\n</tr>\n<tr>\n<td>multianewarray</td>\n<td>创建指定类型和指定维度的多维数组(执行该指令时, 操作栈中必须包含各维度的长度值), 并将其引用压入栈顶</td>\n</tr>\n<tr>\n<td>ifnull</td>\n<td>为null时跳转</td>\n</tr>\n<tr>\n<td>ifnonnull</td>\n<td>不为null时跳转</td>\n</tr>\n<tr>\n<td>goto_w</td>\n<td>无条件跳转(宽索引)</td>\n</tr>\n<tr>\n<td>jsr_w</td>\n<td>跳转至指定的32位offset位置, 并将jsr_w的下一条指令地址压入栈顶</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"计算模型\" style=\"position:relative;\"><a href=\"#%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B\" aria-label=\"计算模型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>计算模型</h2>\n<p>Java字节码的计算模型是面向堆栈结构计算机的。例如，一个x86处理器的汇编代码如下</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">mov eax, byte <span class=\"token punctuation\">[</span>ebp-4<span class=\"token punctuation\">]</span>\r\nmov edx, byte <span class=\"token punctuation\">[</span>ebp-8<span class=\"token punctuation\">]</span>\r\n<span class=\"token function\">add</span> eax, edx\r\nmov ecx, eax</code></pre></div>\n<p>这段代码将两个数值相加，并存入另一个地址。相似的反汇编字节码如下</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token number\">0</span> iload_1\r\n<span class=\"token number\">1</span> iload_2\r\n<span class=\"token number\">2</span> iadd\r\n<span class=\"token number\">3</span> istore_3</code></pre></div>\n<p>在这里，需要相加的两个操作数被放入堆栈，而相加操作就在栈中进行，其结果也被放入堆栈。存储指令之后把栈顶的数据放入一个变量地址。在每条指令前面的数字仅仅是表示这条指令到方法开始处的偏移值。这种堆栈结构也可以推广到面向对象模型上。例如，有一个”getName”方法如下</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"> <span class=\"token class-name\">Method</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n <span class=\"token number\">0</span> aload_0       <span class=\"token comment\">// \"this\"对象被存入变量0</span>\r\n <span class=\"token number\">1</span> getfield #<span class=\"token number\">5</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Field</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>String</span> name<span class=\"token punctuation\">></span></span>\r\n                 <span class=\"token comment\">// 这个指令从栈顶取出一个对象，并从中搜索一个指定的域</span>\r\n                 <span class=\"token comment\">// 并将相应的数据存入栈顶。</span>\r\n                 <span class=\"token comment\">// 这个例子中，\"name\"域对应于该类中的第五个常量。</span>\r\n \r\n <span class=\"token number\">4</span> areturn  \t <span class=\"token comment\">// 返回栈顶的对象作为函数的返回值</span></code></pre></div>\n<h2 id=\"例子\" style=\"position:relative;\"><a href=\"#%E4%BE%8B%E5%AD%90\" aria-label=\"例子 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例子</h2>\n<p>考虑如下Java代码</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  outer<span class=\"token operator\">:</span>\r\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">%</span> j <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\r\n              <span class=\"token keyword\">continue</span> outer<span class=\"token punctuation\">;</span>\r\n      <span class=\"token punctuation\">}</span>\r\n      <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span>println <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>假设上述代码位于一个函数中，Java编译器可能将代码翻译成下述的Java字节码。</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">  <span class=\"token number\">0</span><span class=\"token operator\">:</span>   iconst_2\r\n  <span class=\"token number\">1</span><span class=\"token operator\">:</span>   istore_1\r\n  <span class=\"token number\">2</span><span class=\"token operator\">:</span>   iload_1\r\n  <span class=\"token number\">3</span><span class=\"token operator\">:</span>   sipush  <span class=\"token number\">1000</span>\r\n  <span class=\"token number\">6</span><span class=\"token operator\">:</span>   if_icmpge       <span class=\"token number\">44</span>\r\n  <span class=\"token number\">9</span><span class=\"token operator\">:</span>   iconst_2\r\n  <span class=\"token number\">10</span><span class=\"token operator\">:</span>  istore_2\r\n  <span class=\"token number\">11</span><span class=\"token operator\">:</span>  iload_2\r\n  <span class=\"token number\">12</span><span class=\"token operator\">:</span>  iload_1\r\n  <span class=\"token number\">13</span><span class=\"token operator\">:</span>  if_icmpge       <span class=\"token number\">31</span>\r\n  <span class=\"token number\">16</span><span class=\"token operator\">:</span>  iload_1\r\n  <span class=\"token number\">17</span><span class=\"token operator\">:</span>  iload_2\r\n  <span class=\"token number\">18</span><span class=\"token operator\">:</span>  irem\r\n  <span class=\"token number\">19</span><span class=\"token operator\">:</span>  ifne    <span class=\"token number\">25</span>\r\n  <span class=\"token number\">22</span><span class=\"token operator\">:</span>  <span class=\"token keyword\">goto</span>    <span class=\"token number\">38</span>\r\n  <span class=\"token number\">25</span><span class=\"token operator\">:</span>  iinc    <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span>\r\n  <span class=\"token number\">28</span><span class=\"token operator\">:</span>  <span class=\"token keyword\">goto</span>    <span class=\"token number\">11</span>\r\n  <span class=\"token number\">31</span><span class=\"token operator\">:</span>  getstatic       #<span class=\"token number\">84</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//Field java/lang/System.out:Ljava/io/PrintStream;</span>\r\n  <span class=\"token number\">34</span><span class=\"token operator\">:</span>  iload_1\r\n  <span class=\"token number\">35</span><span class=\"token operator\">:</span>  invokevirtual   #<span class=\"token number\">85</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//Method java/io/PrintStream.println:(I)V</span>\r\n  <span class=\"token number\">38</span><span class=\"token operator\">:</span>  iinc    <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span>\r\n  <span class=\"token number\">41</span><span class=\"token operator\">:</span>  <span class=\"token keyword\">goto</span>    <span class=\"token number\">2</span>\r\n  <span class=\"token number\">44</span><span class=\"token operator\">:</span>  <span class=\"token keyword\">return</span></code></pre></div>\n<h2 id=\"基于java字节码的语言\" style=\"position:relative;\"><a href=\"#%E5%9F%BA%E4%BA%8Ejava%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E8%AF%AD%E8%A8%80\" aria-label=\"基于java字节码的语言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>基于Java字节码的语言</h2>\n<p>Groovy, 一种基于Java的脚本语言\r\nScala,一种类型安全的通用编程语言，支持面向对象编程和函数式编程\r\nClojure, 一种函数式的通用编程语言，提供优秀的并发性。是一种LISP方言</p>\n<h2 id=\"对动态语言的支持\" style=\"position:relative;\"><a href=\"#%E5%AF%B9%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E7%9A%84%E6%94%AF%E6%8C%81\" aria-label=\"对动态语言的支持 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>对动态语言的支持</h2>\n<p>Java虚拟机对动态类型语言提供了一定的支持。但绝大多数的Java虚拟机指令集是基于静态类型语言的。在静态类型机制下，方法调用中的类型分析都是在编译时执行的，而且缺乏一种机制在运行时确定一个类型已经确定相应的方法。</p>\n<p>JSR292中，在Java虚拟机层次增加了一种支持动态类型的指令<code class=\"language-text\">invokedynamic</code>，以支持在动态类型检测中的方法调用。 达芬奇机器则是一种支持这种动态类型调用的虚拟机。 而所有支持JSE 7的Java虚拟机都应支持<code class=\"language-text\">invokedynamic</code>操作码。</p>\n<h2 id=\"参考连接\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83%E8%BF%9E%E6%8E%A5\" aria-label=\"参考连接 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考连接</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions\">https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Java%E5%AD%97%E8%8A%82%E7%A0%81#cite_note-5\">https://zh.wikipedia.org/wiki/Java%E5%AD%97%E8%8A%82%E7%A0%81#cite_note-5</a></li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#%E6%8C%87%E4%BB%A4\">指令</a></li>\n<li><a href=\"#%E6%8C%87%E4%BB%A4%E9%9B%86\">指令集</a></li>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B\">计算模型</a></li>\n<li><a href=\"#%E4%BE%8B%E5%AD%90\">例子</a></li>\n<li><a href=\"#%E5%9F%BA%E4%BA%8Ejava%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E8%AF%AD%E8%A8%80\">基于Java字节码的语言</a></li>\n<li><a href=\"#%E5%AF%B9%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E7%9A%84%E6%94%AF%E6%8C%81\">对动态语言的支持</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E8%BF%9E%E6%8E%A5\">参考连接</a></li>\n</ul>","frontmatter":{"title":"Java字节码和指令集","tags":["coding","java"],"description":"理解字节码以及理解Java编译器如何生成Java字节码与学习汇编知识对于C/C++程序员有一样的意义。","date":"2023-06-30"}}},"pageContext":{"slug":"/java-bytecode-and-instructions","previous":{"fields":{"slug":"/software-architecture-summarize"},"frontmatter":{"title":"软件架构的概述和构件","tags":["coding"],"slug":"/software-architecture-summarize"}},"next":{"fields":{"slug":"/wind-term-hanging-problem"},"frontmatter":{"title":"WindTerm 2.5.0 输入用户名后假死卡住的解决办法","tags":["coding"],"slug":"/wind-term-hanging-problem"}}}},"staticQueryHashes":["2052298874"],"slicesMap":{}}