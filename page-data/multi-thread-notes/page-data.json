{"componentChunkName":"component---src-templates-blog-post-js","path":"/multi-thread-notes/","result":{"data":{"site":{"siteMetadata":{"title":"Jason Yang's Blog"}},"markdownRemark":{"id":"66468516-bf26-5fc1-8a40-365d9406df77","excerpt":"Java的重要功能之一就是内部支持多线程-在一个程序中允许同时运行多个任务。 线程的概念 线程是指一个任务从头到尾的执行流程。 一个Java…","html":"<p>Java的重要功能之一就是内部支持多线程-在一个程序中允许同时运行多个任务。</p>\n<h2>线程的概念</h2>\n<blockquote>\n<p><strong>线程</strong>是指一个任务从头到尾的执行流程。</p>\n</blockquote>\n<p>一个Java程序中可以并发的启动多个线程，这些线程可以在多个处理器上同时运行。</p>\n<p>多线程可以使程序反应更快，交互性更强，执行效率更高，即使再单核处理器的系统上，多线程程序的运行速度也比单线程速度更快。</p>\n<p>在单处理器系统中，多个线程共享CPU时间，称为时间分享，操作系统负责调度及分配资源给它们。CPU分配给线程的时间称为时间片，一般是几十ms，获得时间片的线程会被CPU切换执行。</p>\n<p>在Java中，每个任务都是<code>Runnable</code>接口的一个实例，也成为<code>可运行对象（runnable object）</code>。</p>\n<h2>创建任务和线程</h2>\n<p>一个任务类必须实现Runnable接口。然后通过线程来执行任务。\n任务就是对象。为了创建任务，必须首先为任务定义一个实现Runnable接口的类。</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 通过实现Runnable接口定义一个任务类\npublic class TaskClass implements Runnable{\n\tpublic TaskClass(){\n\t\n\t}\n\t\n\tpublic void run(){\n\t\t// do something...\n\t}\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 创建一个任务、一个线程以及启动线程的步骤\npublic class Client{\n\tpublic void someMethod(){\n\t\t//  创建一个TaskClass实例\n\t\tTaskClass task = new TaskClass();\n\t\t// 创建一个线程\n\t\tThread thread = new Thread(task);\n\t\t// 启动线程\n\t\tthread.start();\n\t}\n}\n</code>\n        </deckgo-highlight-code>\n<h3>实战</h3>\n<blockquote>\n<p>创建三个任务，然后创建三个线程，运行这些任务:</p>\n<p>第一个任务打印字母a100次</p>\n<p>第二个任务打印字母b100次</p>\n<p>第三个任务打印1到100的整数</p>\n</blockquote>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">package org.nocoder.thread;\n\n/**\n * 创建三个任务以及三个运行这些任务的线程:\n * 第一个任务打印字母a100次\n * 第二个任务打印字母b100次\n * 第三个任务打印1到100的整数\n *\n * @author jason\n * @date 18/4/3.\n */\npublic class TaskThreadDemo {\n    public static void main(String[] args){\n        // 创建任务类\n        Runnable printA = new PrintChar(&#39;a&#39;, 100);\n        Runnable printB = new PrintChar(&#39;b&#39;, 100);\n        Runnable print100 = new PrintNumber(100);\n        // 创建线程\n        Thread threadPrintA = new Thread(printA);\n        Thread threadPrintB = new Thread(printB);\n        Thread threadPrint100 = new Thread(print100);\n        // 启动线程\n        threadPrintA.start();\n        threadPrintB.start();\n        threadPrint100.start();\n    }\n\n}\n\n/**\n * 打印字符任务类\n */\nclass PrintChar implements Runnable {\n    /**\n     * 需要打印的字符\n     */\n    private char charToPrint;\n\n    /**\n     * 需要打印的次数\n     */\n    private int times;\n\n    public PrintChar(char c, int t) {\n        charToPrint = c;\n        times = t;\n    }\n\n    public void run() {\n        for (int i = 0; i &lt; times; i++) {\n            System.out.print(charToPrint);\n        }\n    }\n}\n\n/**\n * 打印数字任务类\n */\nclass PrintNumber implements Runnable {\n    /**\n     * 需要打印的最大值\n     */\n    private int lastNum;\n\n    public PrintNumber(int n) {\n        lastNum = n;\n    }\n\n    public void run() {\n        for (int i = 1; i &lt;= lastNum; i++) {\n            System.out.print(&quot; &quot; + i);\n        }\n    }\n\n\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>任务中的run()方法指名如何完成这个任务，Java虚拟机通过调用任务的run()方法执行任务，无需程序员特意调用，直接调用run()方法只是在同一个线程中执行该方法，而没有新线程被启动。</p>\n</blockquote>\n<h2>Thread类</h2>\n<p>Thread类包含为任务而创建的线程的构造方法，以及控制线程的方法。</p>\n<p>Thread类实现了Runnable接口，所以可以定一个Thread的扩展类，实现Runnable的run()方法，然后客户端类创建这个类的一个对象，调用start()启动线程。</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">package org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/3.\n */\npublic class CustomeThread extends Thread {\n    public CustomeThread(){\n\n    }\n\n    public void run(){\n        System.out.println(Thread.currentThread().getName() + &quot;: do something...&quot;);\n    }\n}\n\nclass Client{\n    public static void main(String[] args){\n        Thread thread1 = new CustomeThread();\n        thread1.setName(&quot;线程1&quot;);\n        thread1.start();\n\n        Thread thread2 = new CustomeThread();\n        thread2.setName(&quot;线程2&quot;);\n        thread2.start();\n    }\n\n}\n</code>\n        </deckgo-highlight-code>\n<p>使用<code>yield()</code>方法为其他线程临时让出CPU时间。</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Thread.yield();</code>\n        </deckgo-highlight-code>\n<p>使用<code>sleep(long mills)</code>可以将该线程设置为休眠以确保其他线程的执行，休眠时间为指定的毫秒数。</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 休眠 1ms\ntry{\n\t...\n\tThread.sleep(1);\n}catch(InterruptedException ex){\n\t// do someting...\n}</code>\n        </deckgo-highlight-code>\n<p><code>Thread.sleep()</code>方法可能抛出一个<code>InterruptedException</code>，这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这样的一个异常。</p>\n<p>使用<code>join()</code>方法使用一个线程等待另一个线程的结束。</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">package org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/6.\n */\npublic class YieldTest {\n    public static void main(String[] args) {\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 1; i &lt;= 10; i++) {\n                    System.out.print(i + &quot; &quot;);\n                }\n                System.out.println();\n            }\n        });\n        t.start();\n        try {\n        \t  // 调用线程t的join()方法，其他线程要等待这个线程执行结束后才会执行\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int j = 11; j &lt;= 20; j++) {\n            System.out.print(j + &quot; &quot;);\n        }\n        System.out.println();\n    }\n}\n</code>\n        </deckgo-highlight-code>\n<p>输出结果：</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">1 2 3 4 5 6 7 8 9 10 \n11 12 13 14 15 16 17 18 19 20 \n</code>\n        </deckgo-highlight-code>\n<p>如果不加join()方法的输出结果顺序不固定</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 \n18 19 20 </code>\n        </deckgo-highlight-code>\n<h2>线程池</h2>\n<h3>使用线程池的好处</h3>\n<p>几乎所有需要异步或者并发执行任务的程序都可以使用线程池，合理的使用线程池有以下几个好处。</p>\n<ul>\n<li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗。</li>\n<li>提高相应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li>提高线程的可管理性。线程时稀缺资源，如果无限制的创建，不仅会消耗系统资源，而且还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>\n</ul>\n<h3>线程池的实现原理</h3>\n<p>先来看看线程池的主要处理流程</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ff53e6b3fbb7fa4659de8e0d702a09c4/df56e/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.49367088607595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB80lEQVR42pVS+0/aYBTtXz+2xEdUcAbilv0GyMMBAkPFMt7MGReesgDqeMwuFLC0pQV6lnsdxsQfFk5ykube2/Ode75PEFNpuD0+BIIh+PzHiJzEEY0l1mIsfopQOIZ8oQQh+DmCPfvBE/cO4Nh3wr4mHe9d2N5xsCkhFI6CWK/foFZroFKto1Kprc1yuYpm8yeEI18Q2VwRjZsmwpEYkhcpKIoCgmVZWAe6rkPweP3I5gr4dnkFp+sjvEcByPKIB5bLJYv+j6s5FqS9z5Piv4KG+XyO2WzGNE0Ti8UchmE816j/coa+V6DNhOBxGOl0DkvLQr3RhCT9wWKx4EFZltFu30LTNK6ZpoFf3R66vT73yVmr1UYqlUE+X4QkSRD8gRAy2QJGozHcHj+y+SIM02RX36+u4fYEWICcTiYTnEQTiH85g6bpLCiKX2GzbWBndx+dTucpQ7oIgqqqPLQCxUDuXoIOoihWoD5lPh5PVitH+EHe3t0jcZpEoVjicGmlUukSZ+cXqNYa/PNg8BuimIaYymA4HL56CZSp4PEGWDCdyeGNbQNO1wc+jZqHh5/w9t0mPydCuVLF5tYutrbtaLU6rwT5lnOFIq5/lNl2t9tDvz/A46OC6VRlR5Tfw4MEXZ9hOJTR6/WZlDnlqKraMxVlir8teVF/QzjBlgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"线程池的主要处理流程\"\n        title=\"\"\n        src=\"/static/ff53e6b3fbb7fa4659de8e0d702a09c4/f058b/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png\"\n        srcset=\"/static/ff53e6b3fbb7fa4659de8e0d702a09c4/c26ae/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png 158w,\n/static/ff53e6b3fbb7fa4659de8e0d702a09c4/6bdcf/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png 315w,\n/static/ff53e6b3fbb7fa4659de8e0d702a09c4/f058b/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png 630w,\n/static/ff53e6b3fbb7fa4659de8e0d702a09c4/40601/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png 945w,\n/static/ff53e6b3fbb7fa4659de8e0d702a09c4/df56e/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png 1188w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>从上图可以看出，使用者提交一个任务后，线程池的处理流程如下：</p>\n<ol>\n<li>判断核心线程池是否已满，如果没有满，则创建一个新的线程执行任务。如果满了，则进入下个流程。</li>\n<li>判断队列是否已满，如果没有满，将任务加入到队列中。如果满了，进入下个流程。</li>\n<li>判断线程池是否已满，如果没有满，则创建一个新的线程执行任务。如果满了，进入下个流程。</li>\n<li>按照策略处理无法执行的任务。</li>\n</ol>\n<p>ThreadPoolExecutor执行示意图</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fbcdd34bb60a9e164186463e7213a9e5/062c8/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.87341772151898%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIElEQVR42o2U2W7iUAyGefNy0T5O565zg1peoi1UkIUkkI2EJSTsePS5MkrRTDtHss5in9//7+OkI/85qqqSyWSilqapZFkms9lM7Xg8yvl81rjOdyCHw0E2m43UdaMXm6aR8Xgsd3dd6ff7cn//IM/PL9LtdmUwGPwMCMDpdJLL5SLL5VKappY4juXp6bcC9Ho9GQ6H8vj4S1zX+xlwu90qGIMZcJPG3nzEUQZ83wLudju12wEwdaMkgBZFoaVg37Fsf5vbDG8TwWg+n6vleS5lWcp6vf43QxgQYCxuAZMk+QK23+9ltVpJB92LxUIDaAnWAMEAKTwCL00cUhlcJt5iUEIbse5YtiiKZDQaqaMsCm0TMgMIE6snYCTAr7FlqckgoYBtSe2Zc8vOBcCMYV3TPonKJRnlQe6VIYdIpdfIbi9JgCWBGUDsuYPPmt/3fQnD8BOQQOgChLG30QZkNqY0PCQoFURIfpUMXTJnaaYSojDSxyHjx/BDfM/XfTyLJc9ySZNUXMeVNM0UlBqCgToFBJ1DkxsEoYKFYaRzEAQqCSbUk+SO4+hjAcAdZOPTtrFaEYDxjWK8IN3Pa/L6r69vup9Op+oHGJ81v8lWyWSHJdn4TeGoqrVK+lxXV4OFM3a0ltSU+7Qchl8Zkgl5ZHddVzzP0zP+JPYPRCYzvve3d21q1gADev1SrK+olV0240J7TwxnwSRQ5gCgymrL+g8hq1zbRQ5qpAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"thread-pool-executor\"\n        title=\"\"\n        src=\"/static/fbcdd34bb60a9e164186463e7213a9e5/f058b/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png\"\n        srcset=\"/static/fbcdd34bb60a9e164186463e7213a9e5/c26ae/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png 158w,\n/static/fbcdd34bb60a9e164186463e7213a9e5/6bdcf/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png 315w,\n/static/fbcdd34bb60a9e164186463e7213a9e5/f058b/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png 630w,\n/static/fbcdd34bb60a9e164186463e7213a9e5/40601/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png 945w,\n/static/fbcdd34bb60a9e164186463e7213a9e5/78612/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png 1260w,\n/static/fbcdd34bb60a9e164186463e7213a9e5/062c8/ThreadPoolExecutor%E6%89%A7%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png 1386w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>如果当前运行的线程数小于corePoolSize，则创建新的线程来执行任务（执行这一步骤需要获取全局锁）</li>\n<li>如果运行的线程数等于或者大于corePoolSize，则将任务加入BlockingQueue</li>\n<li>如果无法将任务加入BlockingQueue，则创建新的线程来处理任务，并调用RejectedExceptionHandler.rejectedExecution()方法</li>\n</ol>\n<p><strong>工作线程</strong>：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。</p>\n<p>线程池中的线程执行任务分两种情况：</p>\n<ol>\n<li>在execute() 方法中创建一个线程时，会让这个线程执行当前任务。</li>\n<li>这个线程执行完上一任务后，会反复从BlockingQueue中获取任务来执行。</li>\n</ol>\n<h3>线程池的使用</h3>\n<p>通过ThreadPoolExecutor来创建一个线程池。</p>\n<p>创建一个线程池需要的几个参数：</p>\n<ol>\n<li>corePoolSize 核心线程数量</li>\n<li>maxPoolSize 线程池最大数量</li>\n<li>runnableTaskQueue 任务队列\n<ol>\n<li>ArrayBlockingQueue 基于数组结构的有界阻塞队列</li>\n<li>LinkedBlockingQueue 基于链表结构的阻塞队列</li>\n<li>SynchronousQueue  不存储元素的阻塞队列</li>\n<li>PriorityBlockingQueue 具有优先级的无线阻塞队列</li>\n</ol>\n</li>\n<li>ThreadFactory 创建线程的工厂，使用guava提供的ThreadFactoryBuilder给线程设置有意义的名字</li>\n<li>RejectedExceptionHandler 当队列和线程池都满了，线程池无法执行新任务时的处理策略\n<ol>\n<li>AbortPolicy 直接抛异常</li>\n<li>CallerRunsPolicy 使用调用者所属的线程来运行</li>\n<li>DiscardOldestPolicy 抛弃队列里的最近一个任务，执行当前任务</li>\n<li>DiscardPolicy 直接抛弃，不处理</li>\n</ol>\n</li>\n<li>keepAliveTime 线程活动保持时间</li>\n<li>TimeUnit 线程活动保持时间的单位</li>\n</ol>\n<p>创建线程池示例：</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">public ExecutorService getExecutorService() {\n    ThreadFactory threadFactory = new ThreadFactoryBuilder().build();\n    ExecutorService executorService = new ThreadPoolExecutor(\n      corePoolSize, maxPoolSize, 20000L,\n      TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;(2500),\n      threadFactory, new ThreadPoolExecutor.CallerRunsPolicy());\n    return executorService;\n}</code>\n        </deckgo-highlight-code>\n<h3>提交任务到线程池</h3>\n<ul>\n<li>\n<p>execute() 用于提交不需要返回值的任务</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">executorService.execute(()-&gt;{\n  // do something\n});</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p>submit() 用于提交需要返回值的任务，任务需要实现Callable 接口，返回值为Future，可以通过future.get()获取返回值，get()方法会阻塞当前线程直到任务完成</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Future future = executorService.submit(new CallableTask());\ntry {\n  Object o = future.get();\n} catch (InterruptedException e) {\n  e.printStackTrace();\n} catch (ExecutionException e) {\n  e.printStackTrace();\n}</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h2>参考文献</h2>\n<ul>\n<li>《Java并发编程的艺术》</li>\n</ul>","frontmatter":{"title":"Java 多线程","date":"2018年04月07日 23:11:04","description":"Java线程和线程池基础知识。"}},"previous":{"fields":{"slug":"/jenkins-ci/"},"frontmatter":{"title":"Jenkins持续集成"}},"next":{"fields":{"slug":"/java-interview-questions/"},"frontmatter":{"title":"几道Java相关的面试题"}}},"pageContext":{"id":"66468516-bf26-5fc1-8a40-365d9406df77","previousPostId":"758a7d60-11a8-5c0f-badc-ae5ca4f68bc3","nextPostId":"71260edd-48b8-5891-8dd0-ea2f52b320d1"}},"staticQueryHashes":["3274528899","3589320610"],"slicesMap":{}}