{"componentChunkName":"component---src-templates-blog-post-js","path":"/arts-28/","result":{"data":{"site":{"siteMetadata":{"title":"Funny Eagle","author":"Jason Yang"}},"markdownRemark":{"id":"a30f504e-4d6a-55c8-bf3b-5a233d779a14","excerpt":"Algorithm Review A Beautiful Race Condition Tip mysqlslap is a diagnostic program designed to emula…","html":"<h2 id=\"algorithm\" style=\"position:relative;\"><a href=\"#algorithm\" aria-label=\"algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithm</h2>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">package org.nocoder.leetcode.solution;\n\nimport java.util.Arrays;\n\n/**\n * 976. Largest Perimeter Triangle\n * &lt;p&gt;\n * Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.\n * &lt;p&gt;\n * If it is impossible to form any triangle of non-zero area, return 0.\n * &lt;p&gt;\n * Example 1:\n * &lt;p&gt;\n * Input: [2,1,2]\n * Output: 5\n * Example 2:\n * &lt;p&gt;\n * Input: [1,2,1]\n * Output: 0\n * Example 3:\n * &lt;p&gt;\n * Input: [3,2,3,4]\n * Output: 10\n * Example 4:\n * &lt;p&gt;\n * Input: [3,6,2,3]\n * Output: 8\n * &lt;p&gt;\n * &lt;p&gt;\n * Note:\n * &lt;p&gt;\n * 3 &lt;= A.length &lt;= 10000\n * 1 &lt;= A[i] &lt;= 10^6\n *\n * @author jason\n * @date 2019/1/19.\n */\npublic class LargestPerimeterTriangle {\n\n    public int largestPerimeter(int[] arr) {\n        Arrays.sort(arr);\n        for (int i = arr.length - 3; i &gt;= 0; --i) {\n            if (arr[i] + arr[i + 1] &gt; arr[i + 2]) {\n                return arr[i] + arr[i + 1] + arr[i + 2];\n            }\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        LargestPerimeterTriangle lpt = new LargestPerimeterTriangle();\n        System.out.println(lpt.largestPerimeter(new int[]{3, 6, 2, 3}));\n    }\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"review\" style=\"position:relative;\"><a href=\"#review\" aria-label=\"review permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Review</h2>\n<p><a href=\"http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html\">A Beautiful Race Condition</a></p>\n<h2 id=\"tip\" style=\"position:relative;\"><a href=\"#tip\" aria-label=\"tip permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tip</h2>\n<p><a href=\"https://dev.mysql.com/doc/refman/8.0/en/mysqlslap.html\"><strong>mysqlslap</strong></a> is a diagnostic program designed to emulate client load for a MySQL server and to report the timing of each stage. It works as if multiple clients are accessing the server.</p>\n<p>mysqlslap是mysql自带的性能测试工具，可以模拟多个mysql客户端连接进行并发测试，输出测试结果。</p>\n<deckgo-highlight-code language=\"shell\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">测试100个并发线程，测试次数1次，自动生成SQL测试脚本，读、写、更新混合测试，自增长字段，测试引擎为innodb，共运行5000次查询\n#mysqlslap -h127.0.0.1 -uroot -p --concurrency=100 --iterations=1 --auto-generate-sql --auto-generate-sql-load-type=mixed --auto-generate-sql-add-autoincrement --engine=innodb --number-of-queries=5000\nBenchmark\nRunning for engine innodb\nAverage number of seconds to run all queries: 0.351 seconds\nMinimum number of seconds to run all queries: 0.351 seconds\nMaximum number of seconds to run all queries: 0.351 seconds\nNumber of clients running queries: 100\nAverage number of queries per client:50</code>\n        </deckgo-highlight-code>\n<h2 id=\"share\" style=\"position:relative;\"><a href=\"#share\" aria-label=\"share permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Share</h2>\n<h3 id=\"理解map\" style=\"position:relative;\"><a href=\"#%E7%90%86%E8%A7%A3map\" aria-label=\"理解map permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>理解Map</h3>\n<p>Map的基本思想是它维护的是键值对，可以使用键来查找值。Java标准库中包含了Map和几种实现，包括<code>HashMap</code>,<code>TreeMap</code>, <code>LinkedHashMap</code>, <code>WeakHashMap</code>, <code>ConcurrentHashMap</code>, <code>IdentityHashMap</code>。它们都实现了Map接口，但是行为特性各不相同，表现在效率，键值对的保存及呈现次序、对象的保存周期、如何在多线程程序中工作和判定<code>key</code>等价的策略等方面。</p>\n<p>以下是一个极简的map实现:</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">package org.nocoder.map;\n\n/**\n * Simple map, associates keys with values\n * low efficiency, fixed size\n * @author yangjinlong\n */\npublic class AssociativeArray&lt;K, V&gt; {\n    private Object[][] pairs;\n    private int index;\n\n    public AssociativeArray(int length) {\n        pairs = new Object[length][2];\n    }\n\n    public void put(K key, V value) {\n        if (index &gt;= pairs.length) {\n            throw new ArrayIndexOutOfBoundsException(&quot;Too many values&quot;);\n        }\n        pairs[index++] = new Object[]{key, value};\n    }\n\n    public V get(K key) {\n        for (int i = 0; i &lt; index; i++) {\n            if (key.equals(pairs[i][0])) {\n                return (V) pairs[i][1];\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i &lt; index; i++) {\n            if (i == 0) {\n                result.append(&quot;{&quot;);\n            }\n            result.append(pairs[i][0].toString());\n            result.append(&quot;=&quot;);\n            result.append(pairs[i][1].toString());\n            if (i &lt; index - 1) {\n                result.append(&quot;, &quot;);\n            } else {\n                result.append(&quot;}&quot;);\n            }\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        AssociativeArray&lt;String, Integer&gt; map = new AssociativeArray&lt;&gt;(2);\n        try {\n            map.put(&quot;Jason&quot;, 29);\n            map.put(&quot;Freda&quot;, 26);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            e.printStackTrace();\n        }\n        System.out.println(map);\n        System.out.println(map.get(&quot;Jason&quot;));\n    }\n}\n</code>\n        </deckgo-highlight-code>\n<p>最常用的Map的实现应该就是 HashMap 了，HashMap的数据结构是由数组和链表构成，Java8以后还加入了红黑树。HashMap中的几个术语需要了解：</p>\n<ul>\n<li>容量：表中的桶位数</li>\n<li>初始容量：在创建时所拥有的桶位数</li>\n<li>尺寸：表中当前存储的项数</li>\n<li>负载因子：尺寸/容量。空表的负载因子是0，半满表的负载因子是0.5，以此类推，HashMap 使用的默认负载因子是0.75，当表达到3/4满时，再进行rehash。</li>\n</ul>\n<blockquote>\n<p>HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个&#x3C;key, value>插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。</p>\n</blockquote>\n<p>HashMap是非线程安全的，所以在并发情况下，HashMap可能会出现死循环导致CPU占用100%，查看耗叔的<a href=\"https://coolshell.cn/articles/9606.html\">疫苗：JAVA HASHMAP的死循环 - CoolShell</a>文章可以了解导致死循环的细节。</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#algorithm\">Algorithm</a></p>\n</li>\n<li>\n<p><a href=\"#review\">Review</a></p>\n</li>\n<li>\n<p><a href=\"#tip\">Tip</a></p>\n</li>\n<li>\n<p><a href=\"#share\">Share</a></p>\n<ul>\n<li><a href=\"#%E7%90%86%E8%A7%A3map\">理解Map</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"ARTS 第 28 周","tags":["coding","arts"],"description":"Algorithm, Reiview, Tip and Share","date":"2019-01-12"}}},"pageContext":{"slug":"/arts-28/","previous":{"fields":{"slug":"/arts-27/"},"frontmatter":{"title":"ARTS 第 27 周","tags":["coding","arts"],"slug":""}},"next":{"fields":{"slug":"/arts-29/"},"frontmatter":{"title":"ARTS 第 29 周","tags":["coding","arts"],"slug":""}}}},"staticQueryHashes":["2052298874"],"slicesMap":{}}