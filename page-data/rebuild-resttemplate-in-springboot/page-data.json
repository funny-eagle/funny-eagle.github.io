{"componentChunkName":"component---src-templates-blog-post-js","path":"/rebuild-resttemplate-in-springboot/","result":{"data":{"site":{"siteMetadata":{"title":"Funny Eagle","author":"Jason Yang"}},"markdownRemark":{"id":"569776b9-9392-56ef-a86e-23bde12c8690","excerpt":"最近有个需求，用户希望RestTemplate能够绕过ssl证书验证，直接访问目标地址。虽然这并不安全，但是作为开发人员，只能有求必应啊。 需要设计一个开关，是否忽略ssl验证，默认为false。而…","html":"<p>最近有个需求，用户希望RestTemplate能够绕过ssl证书验证，直接访问目标地址。虽然这并不安全，但是作为开发人员，只能有求必应啊。</p>\n<p>需要设计一个开关，是否忽略ssl验证，默认为false。而且配置得动态刷新，也就是说，一旦修改了配置，就要重新生成一个RestTemplate。</p>\n<p>实现思路如下：</p>\n<ol>\n<li>增加一个配置<code class=\"language-text\">rest-template.ignore-ssl-validation</code>，初始值为<code class=\"language-text\">false</code>。</li>\n<li>修改<code class=\"language-text\">RestTemplate</code>初始化逻辑，根据配置来决定生成的<code class=\"language-text\">RestTemplate</code>的方式。</li>\n<li>写一个<code class=\"language-text\">RestTempalteRebuilder</code>类，包含重新生成<code class=\"language-text\">RestTemplate</code>的逻辑，新建一个<code class=\"language-text\">RestTemplate  bean</code>，从<code class=\"language-text\">spring</code>中销毁旧的<code class=\"language-text\">bean</code>，再向<code class=\"language-text\">spring</code>中注册新的<code class=\"language-text\">bean</code>。</li>\n<li>实现一个<code class=\"language-text\">ApplicationListener</code>，监听<code class=\"language-text\">RefreshEvent</code>事件，如果该配置发生变化，则调用<code class=\"language-text\">RestTempalteRebuilder</code>的重建<code class=\"language-text\">RestTemplate</code>方法。</li>\n</ol>\n<p>遇到的问题：</p>\n<ol>\n<li><code class=\"language-text\">ApplicationListener</code> 初始化完成后，注解了<code class=\"language-text\">@ConfigurationProperties</code>的类还没有初始化完，获取的值为<code class=\"language-text\">null</code> ！！！</li>\n<li><code class=\"language-text\">ApplicationListener</code> 的执行顺序在 <code class=\"language-text\">RefreshEventListener</code>之前，当监听器触发时，获取不到变化后的值，慢了整整一个八拍！！！</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>实现 <code class=\"language-text\">InitialingBean</code> 和 <code class=\"language-text\">afterPropertiesSet()</code> 方法，意思时在依赖的bean全部初始化好之后执行这个方法，所以可以在这里方法里去初始化读取到的配置的值。</li>\n<li>注入 <code class=\"language-text\">ContextRefresher</code>，当自定义的监听器执行的时候，就去刷新以下缓存，就可以取到变化后的值了。</li>\n</ol>\n<p>替换context中的bean</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">DefaultSingletonBeanRegistry</span> registry <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">DefaultSingletonBeanRegistry</span><span class=\"token punctuation\">)</span> applicationContext<span class=\"token punctuation\">.</span><span class=\"token function\">getAutowireCapableBeanFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nregistry<span class=\"token punctuation\">.</span><span class=\"token function\">destroySingleton</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"restTemplate\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nregistry<span class=\"token punctuation\">.</span><span class=\"token function\">registerSingleton</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"restTemplate\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<p>首先从<code class=\"language-text\">ApplicationContext</code>中获取到<code class=\"language-text\">DefaultSingletonBeanRegistry</code>，使用<code class=\"language-text\">destroySingleton()</code>来销毁<code class=\"language-text\">restTemplate bean</code>， 然后使用<code class=\"language-text\">registerSingleton()</code>将新建好的<code class=\"language-text\">bean</code>再注册进去，这个<code class=\"language-text\">registerSingleton()</code> 方法不仅会在 <code class=\"language-text\">ApplicationContext</code> 中创建 <code class=\"language-text\">bean</code>，还会自动将其注入到依赖的对象中，完美。</p>","tableOfContents":"","frontmatter":{"title":"在Springboot中重建RestTemplate Bean","tags":["coding","java"],"description":"Spring Bean 花样玩法，监听配置变化后销毁并重新注册Bean","date":"2024-06-03"}}},"pageContext":{"slug":"/rebuild-resttemplate-in-springboot","previous":{"fields":{"slug":"/coupling-and-cohesion"},"frontmatter":{"title":"内聚性和耦合性","tags":["coding"],"slug":"/coupling-and-cohesion"}},"next":{"fields":{"slug":"/two-nextjs-blog-problems"},"frontmatter":{"title":"Tailwind Nextjs Starter Blog 的两个配置问题","tags":["coding"],"slug":"/two-nextjs-blog-problems"}}}},"staticQueryHashes":["2052298874"],"slicesMap":{}}