{"componentChunkName":"component---src-templates-blog-post-js","path":"/arts-46/","result":{"data":{"site":{"siteMetadata":{"title":"Funny Eagle","author":"Jason Yang"}},"markdownRemark":{"id":"ef2fea0e-cbc3-57b8-8d0c-8aba90962277","excerpt":"历史ARTS Algorithm Review 以前在完成Review这一项任务的时候，通过皓哥的专栏和引导，发现了很多优秀的国外技术网站，如medium、DZone、javatpoint、IBM …","html":"<blockquote>\n<p><a href=\"https://github.com/funny-eagle/arts\">历史ARTS</a></p>\n</blockquote>\n<h2 id=\"algorithm\" style=\"position:relative;\"><a href=\"#algorithm\" aria-label=\"algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Algorithm</h2>\n<pre><code class=\"language-java\">package org.nocoder.leetcode.solution;\n\n/**\n * AddBinary https://leetcode.com/problems/add-binary/\n * &#x3C;p>\n * Given two binary strings a and b, return their sum as a binary string.\n * &#x3C;p>\n * Example 1:\n * &#x3C;p>\n * Input: a = \"11\", b = \"1\"\n * Output: \"100\"\n * Example 2:\n * &#x3C;p>\n * Input: a = \"1010\", b = \"1011\"\n * Output: \"10101\"\n * Constraints:\n * &#x3C;p>\n * 1 &#x3C;= a.length, b.length &#x3C;= 104\n * a and b consist only of '0' or '1' characters.\n * Each string does not contain leading zeros except for the zero itself.\n * Related Topics\n * Math\n * String\n * Bit Manipulation\n * Simulation\n *\n * @author yangjl\n * @description\n * @date 2023-05-19 15:31\n **/\npublic class AddBinary {\n    public String addBinary(String a, String b) {\n        if (a == null || b == null || a.length() > 10000 || b.length() > 10000)\n            throw new RuntimeException(\"invalid parameters\");\n\n        // 两个字符串长度查，在短字符串前面补领0，方便计算\n        int d = a.length() - b.length();\n        String prefix = \"\";\n        for (int i = 0; i &#x3C; Math.abs(d); i++)\n            prefix += \"0\";\n\n        // 参数前面补0\n        if (d > 0)\n            b = prefix + b;\n        else\n            a = prefix + a;\n\n        String[] aa = a.split(\"\");\n        String[] bb = b.split(\"\");\n        // 用字符串数组来存储结果，长度用aa和bb的都可以\n        String[] res = new String[aa.length];\n\n        // carry表示进位值\n        String carry = \"0\";\n\n        // 从末位开始相加\n        for (int i = aa.length - 1; i >= 0; i--) {\n            String sum = carry + aa[i] + bb[i];\n\n            if (\"000\".equals(sum)) {\n                res[i] = \"0\";\n                carry = \"0\";\n            }\n\n            if (\"001\".equals(sum) || \"010\".equals(sum) || \"100\".equals(sum)) {\n                res[i] = \"1\";\n                carry = \"0\";\n            }\n\n            if (\"101\".equals(sum) || \"110\".equals(sum) || \"011\".equals(sum)) {\n                res[i] = \"0\";\n                carry = \"1\";\n            }\n\n            if (\"111\".equals(sum)) {\n                res[i] = \"1\";\n                carry = \"1\";\n            }\n\n            // 计算到数组首位时，依然有进位，需要变长数组，长度+1，首位赋值为1\n            if (i == 0 &#x26;&#x26; \"1\".equals(carry)) {\n                // step1. 暂存res到temp\n                String[] tem = res;\n                // step2. 新建一个比原数组长度+1的数组\n                res = new String[aa.length + 1];\n                // step3. 首位赋值为1\n                res[0] = \"1\";\n                // step4. 把原数组内容复制过来，下标从1开始复制\n                for (int i1 = 1; i1 &#x3C; res.length; i1++)\n                    res[i1] = tem[i1 - 1];\n            }\n\n        }\n\n        String result = new String();\n        for (int i = 0; i &#x3C; res.length; i++)\n            result += res[i];\n\n        return result;\n    }\n}\n\n</code></pre>\n<h2 id=\"review\" style=\"position:relative;\"><a href=\"#review\" aria-label=\"review permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Review</h2>\n<p>以前在完成Review这一项任务的时候，通过皓哥的专栏和引导，发现了很多优秀的国外技术网站，如<a href=\"https://medium.com/\">medium</a>、<a href=\"https://dzone.com\">DZone</a>、<a href=\"https://www.javatpoint.com/\">javatpoint</a>、<a href=\"https://www.ibm.com/\">IBM Developer</a>等等，阅读高质量的英文文章，可以提高英文水平，也可以学习大佬对技术理解的视角和思维方式。今天阅读的是dzone上一位大佬总结的java11到java17的新特性<a href=\"https://dzone.com/articles/whats-new-between-java-11-and-java-17\">What’s New Between Java 11 and Java 17</a>，篇幅不长，可以快速了解上一个LTS版本Java11到17的一些新特性。下面对文中提到的新特性作以下简要整理。</p>\n<ol>\n<li>\n<p>Text Blocks</p>\n<ul>\n<li>文本块，类似python中的文本块支持换行。\n<pre><code class=\"language-java\">public class TextBlock {\n    public static void main(String[] args) {\n        String json = \"\"\"\n                {\n                    \"name\": \"Jason\",\n                    \"age\": \"34\",\n                    \"mail\": \"yangjinlong86@gmail.com\"\n                }\n                \"\"\";\n        System.out.println(json);\n    }\n}\n</code></pre>\n输出结果也是带格式的\n<pre><code class=\"language-json\">{\n    \"name\": \"Jason\",\n    \"age\": \"34\",\n    \"mail\": \"yangjinlong86@gmail.com\"\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>Switch Expressions</p>\n<ul>\n<li>冒号改为箭头方式，不需要单独写<code>break</code>，代码更简洁\n<pre><code class=\"language-java\">private static void withSwitchExpression(Fruit fruit) {\n    switch (fruit) {\n        case APPLE, PEAR -> System.out.println(\"Common fruit\");\n        case ORANGE, AVOCADO -> System.out.println(\"Exotic fruit\");\n        default -> System.out.println(\"Undefined fruit\");\n    }\n}\n</code></pre>\n</li>\n<li>支持返回值，如果一个case下需要多行代码，使用<code>yield</code>关键字指定返回值\n<pre><code class=\"language-java\">private static void withYield(Fruit fruit) {\n    String text = switch (fruit) {\n        case APPLE, PEAR -> {\n            System.out.println(\"the given fruit was: \" + fruit);\n            yield \"Common fruit\";\n        }\n        case ORANGE, AVOCADO -> \"Exotic fruit\";\n        default -> \"Undefined fruit\";\n    };\n    System.out.println(text);\n}\n</code></pre>\n</li>\n<li><code>yield</code>支持旧的 switch 语法，也不需要单独写<code>break</code>\n<pre><code class=\"language-java\">private static void oldStyleWithYield(Fruit fruit) {\n    System.out.println(switch (fruit) {\n        case APPLE, PEAR:\n            yield \"Common fruit\";\n        case ORANGE, AVOCADO:\n            yield \"Exotic fruit\";\n        default:\n            yield \"Undefined fruit\";\n    });\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>Records</p>\n<ul>\n<li>Records 用来创建一个不可变的数据类，与传统的类相比，无需我们再写构造器, getters, hashCode, equals 和 toString方法</li>\n<li>使用new 创建Record时，如果参数与已经存在的Record相同，那么不会新建的Record副本与原Record是同一个实例。见以下代码最后一行的输出，hashcode是一样的。\n<pre><code class=\"language-java\">private static void basicRecord() {\n    record GrapeRecord(Color color, int nbrOfPits) {}\n    GrapeRecord grape1 = new GrapeRecord(Color.BLUE, 1);\n    GrapeRecord grape2 = new GrapeRecord(Color.WHITE, 2);\n    System.out.println(\"Grape 1 is \" + grape1);\n    System.out.println(\"Grape 2 is \" + grape2);\n    System.out.println(\"Grape 1 equals grape 2? \" + grape1.equals(grape2));\n    GrapeRecord grape1Copy = new GrapeRecord(grape1.color(), grape1.nbrOfPits());\n    System.out.println(\"Grape 1 equals its copy? \" + grape1.equals(grape1Copy));\n    System.out.println(grape1.hashCode() + \" \" + grape1Copy.hashCode());\n}\n</code></pre>\n<pre><code class=\"language-log\">Grape 1 is GrapeRecord[color=java.awt.Color[r=0,g=0,b=255], nbrOfPits=1]\nGrape 2 is GrapeRecord[color=java.awt.Color[r=255,g=255,b=255], nbrOfPits=2]\nGrape 1 equals grape 2? false\nGrape 1 equals its copy? true\n-520085790 -520085790\n</code></pre>\n</li>\n<li>Record的构造方法中可以增加字段校验逻辑\n<pre><code class=\"language-java\">    private static void basicRecordWithValidation() {\n        record GrapeRecord(Color color, int nbrOfPits) {\n            GrapeRecord {\n                System.out.println(\"Parameter color=\" + color + \", Field color=\" + this.color());\n                System.out.println(\"Parameter nbrOfPits=\" + nbrOfPits + \", Field nbrOfPits=\" + this.nbrOfPits());\n                if (color == null) {\n                    throw new IllegalArgumentException(\"Color may not be null\");\n                }\n            }\n        }\n        GrapeRecord grape1 = new GrapeRecord(Color.BLUE, 1);\n        System.out.println(\"Grape 1 is \" + grape1);\n        GrapeRecord grapeNull = new GrapeRecord(null, 2);\n    }\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>Sealed Classes</p>\n<ul>\n<li>使用关键字<code>sealed</code>配合<code>permits</code>来限定类的继承范围，不被允许的类继承该类会编译错误，提示<code>'ClassName' is not allowed in the sealed hierarchy</code></li>\n<li>继承了该类的子类需要声明自身的继承范围，使用关键字<code>final</code>、<code>sealed</code>和<code>non-sealed</code>来限定继承范围</li>\n</ul>\n</li>\n<li>\n<p>Pattern matching for instanceof</p>\n<ul>\n<li><code>instanceof</code>的类名之后，跟一个变量名，可以省去强转和声明类的步骤\n<pre><code class=\"language-java\">Object o = new GrapeClass(Color.BLUE, 2);\nif (o instanceof GrapeClass grape) {\n    System.out.println(\"This grape has \" + grape.getNbrOfPits() + \" pits.\");\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>Helpful NullPointerExceptions</p>\n<ul>\n<li>当发生空指针异常是，异常信息中直接会告诉你是哪个类的哪个方法导致的\n<pre><code class=\"language-java\">Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke \"com.mydeveloperplanet.myjava17planet.GrapeClass.getColor()\" because the return value of \"java.util.HashMap.get(Object)\" is null\n</code></pre>\n</li>\n</ul>\n<p>    at com.mydeveloperplanet.myjava17planet.HelpfulNullPointerExceptions.main(HelpfulNullPointerExceptions.java:13)\n```</p>\n</li>\n<li>\n<p>Compact Number Formatting Support</p>\n<ul>\n<li><code>NumberFormat</code>类中增加了<code>format</code>工厂方法，便于数字类型转换</li>\n</ul>\n</li>\n<li>\n<p>Day Period Support Added</p>\n<ul>\n<li><code>DateTimeFormatter</code> 中新增了一个<code>B</code>模式，可以直接返回时间所属的时段信息</li>\n</ul>\n<pre><code class=\"language-java\">public class DayPeriod {\n    public static void main(String[] args) {\n        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"B\");\n        System.out.println(dtf.format(LocalTime.of(8, 0)));\n        System.out.println(dtf.format(LocalTime.of(13, 0)));\n        System.out.println(dtf.format(LocalTime.of(20, 0)));\n        System.out.println(dtf.format(LocalTime.of(23, 0)));\n        System.out.println(dtf.format(LocalTime.of(0, 0)));\n    }\n}\n</code></pre>\n<pre><code class=\"language-log\">上午\n下午\n晚上\n晚上\n午夜\n</code></pre>\n<p>默认返回值是当前时区，也可以指定Locale，例如：</p>\n<pre><code class=\"language-java\">dtf = DateTimeFormatter.ofPattern(\"B\").withLocale(Locale.forLanguageTag(\"NL\"));\n</code></pre>\n</li>\n<li>\n<p>Stream.toList()</p>\n<ul>\n<li>旧版本中，如果要把Stream转换成List，需要调用<code>collect(Collectors.toList)</code>，Java 17 中，<code>Stream</code>增加了<code>toList()</code>方法，可以直接转换为<code>List</code>\n<pre><code class=\"language-java\">private static void oldStyle() {\n    Stream&#x3C;String> stringStream = Stream.of(\"a\", \"b\", \"c\");\n    List&#x3C;String> stringList =  stringStream.collect(Collectors.toList());\n    for(String s : stringList) {\n        System.out.println(s);\n    }\n}\n\nprivate static void streamToList() {\n    Stream&#x3C;String> stringStream = Stream.of(\"a\", \"b\", \"c\");\n    List&#x3C;String> stringList =  stringStream.toList();\n    for(String s : stringList) {\n        System.out.println(s);\n    }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"tip\" style=\"position:relative;\"><a href=\"#tip\" aria-label=\"tip permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tip</h2>\n<p>使用RabbitMQ时，如果设置了自动ack，再自行手动ack的话，会偶发性的导致消息丢失。</p>\n<p><strong>问题现象</strong></p>\n<p>A服务将数据通过MQ发送到B服务，期间出现消息丢失情况。</p>\n<p><strong>排查过程</strong></p>\n<p>1、A服务发送成功后记录了日志，消息是成功发送出去了。\n2、B服务日志打印不规范，输出日志为null，经核实代码，推断<code>message</code>为空，导致<code>RuntimeException</code>。\n3、查看RabbitMQ日志，发现异常信息如下：</p>\n<pre><code class=\"language-log\">2023-05-29 23:52:01.502 [error] &#x3C;0.20990.12> Channel error on connection &#x3C;0.2510.0> (10.42.0.1:42792 -> 10.42.0.5:5672, vhost: '/', user: 'admin'), channel 1150:\noperation basic.ack caused a channel exception precondition_failed: unknown delivery tag 1\n</code></pre>\n<p><strong>问题原因</strong></p>\n<p>到此问题基本明晰了，生产环境的配置文件没有将rabbitmq的ack设置为手动，默认值为<code>none</code>，是自动确认。代码中使用<code>channel.basicAck()</code>又进行了手动确认，这样的重复确认操作会导致<strong>偶发性</strong>消息丢失情况。</p>\n<p>rabbitmq 为每一个channel维护了一个delivery tag的计数器，采用正向自增，新消息投递时自增，当消息响应时自减；在连续收发的场景中，由于消息发送的间隔较短，部分消息因 consumer的重复确认被rabbitmq 当做已处理而丢弃。</p>\n<p><strong>解决办法</strong></p>\n<p>取消自动确认，配置手动确认。</p>\n<pre><code class=\"language-yml\">spring:\n  rabbitmq:\n    host: ${rabbitmqHost}\n    port: ${rabbitmqPort}\n    username: ${rabbitmqUsername}\n    password: ${rabbitmqPassword}\n    virtual-host: /\n    listener:\n      simple:\n        retry:\n          enabled: true\n          max-attempts: 24\n          initial-interval: 3600000\n        acknowledge-mode: manual\n</code></pre>\n<h2 id=\"share\" style=\"position:relative;\"><a href=\"#share\" aria-label=\"share permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Share</h2>\n<ul>\n<li>MegaEase纪念陈皓的<a href=\"https://memorial.megaease.cn/\">网站</a></li>\n<li>IBM Developer 中文网站已经在2021年3月15日关停，附上一个github上的<a href=\"https://github.com/nocdr/ibm_bak\">文章备份仓库</a>。</li>\n<li><a href=\"https://github.com/funny-eagle/arts\">历史ARTS</a></li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#algorithm\">Algorithm</a></li>\n<li><a href=\"#review\">Review</a></li>\n<li><a href=\"#tip\">Tip</a></li>\n<li><a href=\"#share\">Share</a></li>\n</ul>","frontmatter":{"title":"ARTS 第46周","tags":["coding","arts"],"description":"时隔两年后的第46篇ARTS，纪念陈皓老师。","date":"2023-06-02"}}},"pageContext":{"slug":"/arts-46/","previous":{"fields":{"slug":"/basic-of-network/"},"frontmatter":{"title":"必须要掌握的网络通信原理","tags":["coding"],"slug":""}},"next":{"fields":{"slug":"/free-ssl-certs/"},"frontmatter":{"title":"申请免费HTTPS证书","tags":["coding"],"slug":""}}}},"staticQueryHashes":["2052298874"],"slicesMap":{}}