{"componentChunkName":"component---src-templates-blog-post-js","path":"/reverse-proxy/","result":{"data":{"site":{"siteMetadata":{"title":"Jason Yang's Blog"}},"markdownRemark":{"id":"ffcc0f7f-4f5a-52db-9bb5-a27edaf73fae","excerpt":"反向代理（Reverse Proxy）方式是指用代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 举个例子，一个用户访问 http://www.example.com…","html":"<blockquote>\n<p><strong>反向代理</strong>（Reverse Proxy）方式是指用代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n</blockquote>\n<p>举个例子，一个用户访问 <a href=\"http://www.example.com/readme\">http://www.example.com/readme</a>，但是 <a href=\"http://www.example.com\">www.example.com</a> 上并不存在 readme 页面，它是偷偷从另外一台服务器上取回来，然后作为自己的内容返回给用户。但是用户并不知情这个过程。对用户来说，就像是直接从 <a href=\"http://www.example.com\">www.example.com</a> 获取 readme 页面一样。这里所提到的 <a href=\"http://www.example.com\">www.example.com</a> 这个域名对应的服务器就设置了反向代理功能。</p>\n<p>反向代理服务器，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/jasonyang86/nocoder/master/data/images/201806/proxy.png\" alt=\"\"></p>\n<h4>反向代理典型应用场景</h4>\n<p>反向代理的典型用途是将防火墙后面的服务器提供给 Internet 用户访问，加强安全防护。反向代理还可以为后端的多台服务器提供负载均衡，或为后端较慢的服务器提供 <strong>缓冲</strong> 服务。另外，反向代理还可以启用高级 URL 策略和管理技术，从而使处于不同 web 服务器系统的 web 页面同时存在于同一个 URL 空间下。</p>\n<p>Nginx 的其中一个用途是做 HTTP 反向代理，下面简单介绍 Nginx 作为反向代理服务器的方法。</p>\n<blockquote>\n<p>场景描述：访问本地服务器上的 README.md 文件 <a href=\"http://localhost/README.md\">http://localhost/README.md</a>，本地服务器进行反向代理，从 <a href=\"https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md\">https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md</a> 获取页面内容。</p>\n</blockquote>\n<p><code>nginx.conf</code> 配置示例：</p>\n<deckgo-highlight-code language=\"nginx\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">worker_processes 1;\n\npid logs/nginx.pid;\nerror_log logs/error.log warn;\n\nevents {\n    worker_connections 3000;\n}\n\nhttp {\n    include mime.types;\n    server_tokens off;\n\n\t## 下面配置反向代理的参数\n    server {\n        listen    8866;\n\n        ## 1. 用户访问 http://ip:port，则反向代理到 https://github.com\n        location / {\n            proxy_pass  https://github.com;\n            proxy_redirect     off;\n            proxy_set_header   Host             $host;\n            proxy_set_header   X-Real-IP        $remote_addr;\n            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n        }\n\n        ## 2.用户访问 http://ip:port/README.md，则反向代理到\n        ##   https://github.com/.../README.md\n        location /README.md {\n            proxy_set_header  X-Real-IP  $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md;\n        }\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>成功启动 Nginx 后，我们打开浏览器，验证下反向代理的效果。在浏览器地址栏中输入 <code>localhost/README.md</code>，返回的结果是我们 GitHub 源代码的 README 页面。如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/moonbingbing/openresty-best-practices/master/images/proxy_example.png\" alt=\"\"></p>\n<p>我们只需要配置一下 <code>nginx.conf</code> 文件，不用写任何 web 页面，就可以偷偷地从别的服务器上读取一个页面返回给用户。</p>\n<p>下面我们来看一下 <code>nginx.conf</code> 里用到的配置项：</p>\n<p>(1) location</p>\n<p>location 项对请求 URI 进行匹配，location 后面配置了匹配规则。例如上面的例子中，如果请求的 URI 是 <code>localhost/</code>，则会匹配 <code>location /</code> 这一项；如果请求的 URI 是 <code>localhost/README.md</code>，则会匹配 <code>location /README.md</code> 这项。</p>\n<p>上面这个例子只是针对一个确定的 URI 做了反向代理，有的读者会有疑惑：如果对每个页面都进行这样的配置，那将会大量重复，能否做 <strong>批量</strong> 配置呢？此时需要配合使用 location 的正则匹配功能。具体实现方法可参考 Nginx 文档中 <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#location\">关于 location 的描述</a>。</p>\n<p>(2) proxy_pass</p>\n<p>proxy_pass 后面跟着一个 URL，用来将请求反向代理到 URL 参数指定的服务器上。例如我们上面例子中的 <code>proxy_pass https://github.com</code>，则将匹配的请求反向代理到 <code>https://github.com</code>。</p>\n<p>(3) proxy_set_header</p>\n<p>默认情况下，反向代理不会转发原始请求中的 Host 头部，如果需要转发，就需要加上这句：<code>proxy_set_header Host $host;</code></p>\n<p>除了上面提到的常用配置项，还有 proxy_redirect、proxy_set_body、proxy_limit_rate 等参数，具体用法可以到<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\">Nginx 官网</a>查看。</p>\n<h4>正向代理</h4>\n<p>既然有反向代理，自然也有正向代理。简单来说，正向代理就像一个跳板，例如一个用户访问不了某网站（例如 <code>www.google.com</code>），但是他能访问一个代理服务器，这个代理服务器能访问 <code>www.google.com</code>，于是用户可以先连上代理服务器，告诉它需要访问的内容，代理服务器去取回来返回给用户。例如一些常见的翻墙工具、游戏代理就是利用正向代理的原理工作的，我们需要在这些正向代理工具上配置服务器的 IP 地址等信息。</p>","frontmatter":{"title":"反向代理","date":"2018年06月06日 02:49:34","description":"了解反向代理并使用Nginx实现"}},"previous":{"fields":{"slug":"/ubuntu-1604-source/"},"frontmatter":{"title":"ubuntu 1604 apt source"}},"next":{"fields":{"slug":"/ubuntu-elasticsearch-install/"},"frontmatter":{"title":"ubuntu 安装 ElasticSearch 过程中的问题记录"}}},"pageContext":{"id":"ffcc0f7f-4f5a-52db-9bb5-a27edaf73fae","previousPostId":"9b56b067-5d50-551e-a431-7f1aaee94d13","nextPostId":"01296763-5e37-513c-8bf6-ff5d9396e270"}},"staticQueryHashes":["3274528899","3589320610"],"slicesMap":{}}