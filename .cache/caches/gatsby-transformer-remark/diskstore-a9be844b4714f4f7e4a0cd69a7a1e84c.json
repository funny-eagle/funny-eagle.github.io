{"expireTime":9007200810533796000,"key":"transformer-remark-markdown-html-98f6cc3405184239e98b76feaf8deb21-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<h2>Algorithm</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>nocoder<span class=\"token punctuation\">.</span>leetcode<span class=\"token punctuation\">.</span>solution</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">TreeMap</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * 933. Number of Recent Calls\n *\n * Write a class RecentCounter to count recent requests.\n *\n * It has only one method: ping(int t), where t represents some time in milliseconds.\n *\n * Return the number of pings that have been made from 3000 milliseconds ago until now.\n *\n * Any ping with time in [t - 3000, t] will count, including the current ping.\n *\n * It is guaranteed that every call to ping uses a strictly larger value of t than before.\n *\n *\n *\n * Example 1:\n *\n * Input: inputs = [\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\"], inputs = [[],[1],[100],[3001],[3002]]\n * Output: [null,1,2,3,3]\n *\n *\n * Note:\n *\n * Each test case will have at most 10000 calls to ping.\n * Each test case will call ping with strictly increasing values of t.\n * Each call to ping will have 1 &lt;= t &lt;= 10^9.\n *\n * @author jason\n * @date 2018/11/18.\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NumbersOfRecentCalls</span> <span class=\"token punctuation\">{</span>\n\t\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">RecentCounter</span> <span class=\"token punctuation\">{</span>\n\n    \t<span class=\"token class-name\">TreeMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> tm<span class=\"token punctuation\">;</span>\n    \t\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">RecentCounter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \ttm <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TreeMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">ping</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        \ttm<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> tm<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> tm<span class=\"token punctuation\">.</span><span class=\"token function\">tailMap</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">-</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * Your RecentCounter object will be instantiated and called as such:\n * RecentCounter obj = new RecentCounter();\n * int param_1 = obj.ping(t);\n */</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Review</h2>\n<h3><a href=\"https://www.javacodegeeks.com/2013/01/java-thread-pool-example-using-executors-and-threadpoolexecutor.html\">Java Thread Pool Example using Executors and ThreadPoolExecutor</a></h3>\n<p>线程池包含一个队列，用于保持任务等待执行。线程池管理Runnable线程的集合，工作线程从队列中执行Runnable。java.util.concurrent.Executors提供java.util.concurrent.Executor接口的实现，以在java中创建线程池。</p>\n<h2>Tip</h2>\n<h3>线程池的饱和策略</h3>\n<blockquote>\n<p>ThreadPoolExecutor 构造方法中包含一个 BlockingQueue 参数，这个队列接收任务，并在线程中执行，如果这个队列满了，就会在创建一个新的线程，将任务放入新线程的Queue中，当线程数量达到线程池大小上限之后，线程池会reject 这个任务，此时 RejectedExceptionHandler 就派上用场了。</p>\n</blockquote>\n<p><strong>饱和策略</strong>：当队列满了之后，饱和策略开始发挥作用，ThreadPoolExecutor 的饱和策略可以通过调用 RejectExceptionHandler 来修改。</p>\n<p>JDK 提供了四种RejectExceptionHandler实现：AbortPolicy，CallerRunsPolicy，DiscardPolicy，DiscardOldestPolicy。</p>\n<p><strong>Abort</strong>: 默认的饱和策略，该策略会抛出RuntimeException</p>\n<p><strong>Discard</strong>：抛弃该任务</p>\n<p><strong>Discard-Oldest</strong>：抛弃下一个奖杯执行的任务，然后尝试重新提交的新任务</p>\n<p><strong>Caller-Runs</strong>：实现了一种调节机制，不会抛弃任务，也不抛出异常，而是将任务退回到调用者，优调用者来执行，从而降低新任务的流量。</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">ThreadPoolExecutor</span> executor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span>\n\tN_THREADS<span class=\"token punctuation\">,</span> N_THREADS<span class=\"token punctuation\">,</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">,</span>\n\t<span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>CAPACITY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nexecutor<span class=\"token punctuation\">.</span><span class=\"token function\">setRejectExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">.</span><span class=\"token class-name\">CallRunsPolicy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Share</h2>\n<h3>正确设置线程池的大小</h3>\n<p>最佳的线程池的大小，取决于被执行的任务和系统硬件。如果线程池过大，大量的线程将在相对很少的CPU和内存资源上发生竞争，这样会导致更多的内存消耗；如果线程池过小，许多空闲的处理器没有得到利用，降低了吞吐量。</p>\n<p>正确的设置线程池的大小，必须分析系统环境，资源和任务的特性，有多少个CPU，多大的内存，任务是计算密集型还是IO密集型，还是二者皆可。</p>\n<p>如果需要执行不同的任务，并且它们之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程池可以根据各自的工作负载来调整。</p>\n<ul>\n<li>\n<p>对于计算密集型的任务</p>\n<ul>\n<li>N个CPU，线程池的大小为N+1时，通常能实现最优的利用率。</li>\n</ul>\n</li>\n<li>\n<p>对于包含IO操作或者其他阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大</p>\n<ul>\n<li>\n<p>估算出任务的等待时间于计算时间的比值\t</p>\n<ul>\n<li>在某个基准负载下，分别设置不同大小的线程池来运行程序，观察CPU利用率</li>\n<li>N = CPU的数量(可以通过<code class=\"language-text\">Runtime.getRuntime().availableProcessors()</code>获取CPU数量)</li>\n<li>U = CPU的使用率(0 &#x3C;= U &#x3C;= 1）</li>\n<li>W/C = 计算等待时间 / 计算时间</li>\n<li>线程池的最优大小 = N * U * (1 + W/C)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"}