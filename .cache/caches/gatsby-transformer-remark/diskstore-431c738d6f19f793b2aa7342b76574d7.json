{"expireTime":9007200810530857000,"key":"transformer-remark-markdown-html-17f0a82dcd63767a3aa85f6c2cd84208-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<h2>引言</h2>\n<blockquote>\n<p>离职后的第一个面试，是一家互联网公司，主要做汽车租赁业务的。第一轮是HR先来聊了半个小时，第二轮是技术面试，面试官大哥的语速可以和HY水哥想提并论了，节奏快的飞起，搞得我有点紧张，问了我几个技术问题，回答的不全面，紧接着就开始问我还有什么想要问公司的了，阿西吧，有点失落，准备不充分，特此针对本次面试题目作一些解答分析和知识点拓展，避免再次尴尬。</p>\n</blockquote>\n<h2>面试题</h2>\n<h3>数据库编码和服务端代码编码一致情况下，Get请求可能产生乱码的原因及解决办法？</h3>\n<ul>\n<li>检查中间键tomcat、jetty对get请求的解码格式，默认是iso-8859-1的话，可能会产生乱码，解决办法修改中间键配置文件中URIEncoding解码格式。</li>\n</ul>\n<h3>Struts2和SpringMVC的区别？</h3>\n<ul>\n<li>Struts2入口是<code class=\"language-text\">Filter</code>，SpringMVC是<code class=\"language-text\">Servlet</code></li>\n<li>Spring MVC是基于方法的设计，而Struts2是基于类</li>\n<li>Spring MVC的方法之间基本上是独立的，独享request和response，而Struts2所有Action变量是共享的</li>\n<li>Struts2有自己的interceptor机制，Spring MVC用的是独立的AOP方式</li>\n</ul>\n<h3>Spring MVC的Controller是单例的吗，有什么影响吗？</h3>\n<ul>\n<li>Spring MVC的controller是单例的</li>\n<li>如果在controller中定义了非静态成员变量，会导致属性重复使用</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 非静态成员变量j的属性值会重复利用，不会累加</span>\n<span class=\"token comment\">// 解决办法：不要定义非静态成员变量，或者使用多例 @Scope(\"prototype\")</span>\n<span class=\"token annotation punctuation\">@Controller</span>\n<span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/test\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">IndexController</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"|\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>MyBatis如何防止sql注入？</h3>\n<p>Mybatis中的<code class=\"language-text\">#{}</code>和<code class=\"language-text\">${}</code>的区别</p>\n<ul>\n<li><code class=\"language-text\">#{}</code>使用的是PreparedStatement，会有类型转换, 将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by “111”, 如果传入的值是id，则解析成的sql为order by “id”</li>\n<li><code class=\"language-text\">${}</code>将传入的数据直接显示生成在sql中。如：order by $user<em>id$，如果传入的值是111,那么解析成sql时的值为order by user</em>id,  如果传入的值是id，则解析成的sql为order by id</li>\n<li><code class=\"language-text\">#{}</code>方式能够很大程度防止sql注入</li>\n<li><code class=\"language-text\">${}</code>方式无法防止Sql注入</li>\n<li><code class=\"language-text\">${}</code>方式一般用于传入数据库对象，例如传入表名</li>\n<li>尽量使用<code class=\"language-text\">#{}</code>代替<code class=\"language-text\">${}</code></li>\n<li>\n<p>参考文献</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000010107964\">https://segmentfault.com/a/1190000010107964</a></li>\n<li><a href=\"https://my.oschina.net/chuibilong/blog/638950\">https://my.oschina.net/chuibilong/blog/638950</a></li>\n<li><a href=\"https://blog.csdn.net/kakaxi_77/article/details/46007239\">https://blog.csdn.net/kakaxi_77/article/details/46007239</a></li>\n</ul>\n</li>\n</ul>\n<h3>Hibernate一级缓存、二级缓存？</h3>\n<ul>\n<li>\n<p>一级缓存</p>\n<ul>\n<li>第一级缓存是 Session 缓存并且是一种强制性的缓存，所有的要求都必须通过它。Session 对象在它自己的权利之下，在将它提交给数据库之前保存一个对象。</li>\n<li>如果你对一个对象发出多个更新，Hibernate 会尝试尽可能长地延迟更新来减少发出的 SQL 更新语句的数目。如果你关闭 session,所有缓存的对象丢失，或是存留，或是在数据库中被更新。</li>\n</ul>\n</li>\n<li>\n<p>二级缓存</p>\n<ul>\n<li>第二级缓存是一种可选择的缓存并且第一级缓存在任何想要在第二级缓存中找到一个对象前将总是被询问。</li>\n<li>第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。</li>\n<li>任何第三方缓存可以和 Hibernate 一起使用。org.hibernate.cache.CacheProvider 接口被提供，它必须实现来给 Hibernate 提供一个缓存实现的解决方法。</li>\n</ul>\n</li>\n<li>\n<p>参考文献</p>\n<ul>\n<li><a href=\"http://wiki.jikexueyuan.com/project/hibernate/caching.html\">http://wiki.jikexueyuan.com/project/hibernate/caching.html</a></li>\n<li><a href=\"https://blog.csdn.net/xlgen157387/article/details/40071651\">https://blog.csdn.net/xlgen157387/article/details/40071651</a> </li>\n</ul>\n</li>\n</ul>\n<h3>使用过哪些socket框架？</h3>\n<h2>延伸</h2>\n<h3>Spring MVC 请求-响应流程</h3>\n<p><img src=\"https://raw.githubusercontent.com/jasonyang86/nocoder/master/data/images/201804/springmvc%E8%AF%B7%E6%B1%82%E8%B7%9F%E8%B8%AA.png\"></p>\n<ul>\n<li>1.浏览器发送请求的url以及其他信息</li>\n<li>2.DispatcherServlet先会查询处理器映射（handler mapping），来确定发送给哪个控制器。</li>\n<li>3.确定合适的控制器后，将请求发送给选中的控制器</li>\n<li>4.控制器完成逻辑处理后，将模型数据打包，并标示出输出的视图名，将请求连同模型和视图名发送回DispatcherServlet</li>\n<li>5.DispatcherServlet使用视图解析器（view resolver）来将逻辑视图名匹配一个特定的视图实现（jsp或其它）</li>\n<li>6.DispatcherServlet匹配到对应的视图实现</li>\n<li>7.视图使用模型数据渲染输出，这个输出通过响应对象传递给客户端</li>\n</ul>\n<h3>struts2 工作流程</h3>\n<p>待续</p>\n<h3>http协议无状态</h3>\n<p>对<strong>无状态</strong>的理解</p>\n<ul>\n<li>协议对于事务处理没有记忆能力</li>\n<li>对同一个url请求没有上下文关系</li>\n<li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li>\n<li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li>\n<li>人生若只如初见</li>\n</ul>\n<p><strong>状态</strong>的含义：客户端和服务器在某次会话中产生的数据。</p>\n<p><strong>无状态</strong>就意味着，这些数据不会被保留，但是通过增加cookie和session机制，现在的网络请求其实是有状态的。</p>\n<p>在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。</p>\n<p>知乎上有个哥们儿举的一个例子：</p>\n<blockquote>\n<p><strong>有状态：</strong></p>\n<p>A：你今天中午吃的啥？</p>\n<p>B：吃的大盘鸡。</p>\n<p>A：味道怎么样呀？</p>\n<p>B：还不错，挺好吃的。</p>\n<p><strong>无状态：</strong></p>\n<p>A：你今天中午吃的啥？</p>\n<p>B：吃的大盘鸡。</p>\n<p>A：味道怎么样呀？</p>\n<p>B：？？？啊？啥？啥味道怎么样？</p>\n<p>所以需要cookie这种东西：</p>\n<p>A：你今天中午吃的啥？</p>\n<p>B：吃的大盘鸡。</p>\n<p>A：你今天中午吃的大盘鸡味道怎么样呀？</p>\n<p>B：还不错，挺好吃的。</p>\n</blockquote>\n<h2>总结</h2>\n<p>花了半个晚上的时间复习、梳理了一下以上内容，收益颇多，真不想打击自己啊，这几年还是没有把这些框架的理论基础打牢固，还好现在吸收这些内容还算比较容易，再接再厉吧，多总结、多动手练习。</p>"}